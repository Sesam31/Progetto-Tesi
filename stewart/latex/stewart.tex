\documentclass[12pt,twoside,openright]{article}
\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{hyperref}
\usepackage[italian]{babel}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows.meta, positioning}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{circuitikz}
\usepackage{frontespizio}

\usepackage[backend=biber,sorting=none]{biblatex}
\usepackage[autostyle,italian=guillemets]{csquotes}
\usepackage{guit}
\usepackage{latexsym}
\addbibresource{./bibliografia.bib}


\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}
\definecolor{orange}{rgb}{0.88, 0.55, 0.24}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{green},
    keywordstyle=\color{orange},
    numberstyle=\tiny\color{black},
    stringstyle=\color{red},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

%\oddsidemargin 0pt
%\evensidemargin 0pt
%\marginparwidth 40pt
%\marginparsep 10pt
%\topmargin -20pt
%\headsep 10pt
%\textheight 8.7in
%\textwidth 6.65in
%\linespread{1.2}

\title{Stabilizzazione nel piano di Gough-Stewart}
\author{Daniele Facco}
\date{}

%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{conjecture}[theorem]{Conjecture}

%\newcommand{\rr}{\mathbb{R}}

%\newcommand{\al}{\alpha}
%\DeclareMathOperator{\conv}{conv}
%\DeclareMathOperator{\aff}{aff}

\begin{document}


  \begin{frontespizio}
    \Logo[3cm]{logo.jpg}
    \Istituzione {Università degli Studi di Trieste}
    \Divisione{dipartimento di Ingegneria e Architettura}
    \Corso [Laurea]{Ingegneria Elettronica e Informatica}
    \Titolo {Stabilizzazione nella piattaforma di Gough-Stewart}
    \Candidato {Daniele Facco}
    \Relatore {Prof. Stefano Marsi}
    \Annoaccademico {2020-2021}
  \end{frontespizio}

%\maketitle
\newpage
\tableofcontents
\newpage

%\begin{abstract}
%Studio della piattaforma di Stewart e dei suoi componenti.
%\end{abstract}

\section{Introduzione}\label{intro}


\section{Tecnologie impiegate}\label{tecnologie}

\subsection{Piattaforma Arduino}\label{arduino}
L'intero progetto si basa su una unità di controllo centrale, è quindi fondamentale impiegare un processore con discrete capacità elaborative. Una scelta molto comune è quella di impiegare schede Arduino, che con il vantaggio di essere OpenHardware hanno raggiunto una discreta ubiquità nel settore, anche grazie ad un ambiente di sviluppo completo e ad un sistema di librerie molto supportato dai produttori di componenti. La scheda impiegata è Arduino UNO con un processore ATmega328P, il quale permette di avere una frequenza di clock di $16MHz$, perfettamente in grado di gestire la rapidità di calcolo richiesta dal progetto. Alla scheda impiegata è stato poi montato uno "shield", un componente che rimappa i pin in modo più conveniente per connettere dispositivi quali servomotori, display LCD, moduli bluetooth e altri oltre che facilitare l'alimentazione esterna tramite appositi morsetti. I pin impiegati sono divisi in base alla periferica; il controllo dei servomotori è svolto dai pin con capacità PWM ovvero 3, 5, 6, 9, 10 e 11, quello del piano resistivo da 12, 13 e A0 mentre per la lettura del joystick sono impiegati A5, A6 e 7.

%Nella realizzazione sono stati impiegati diversi pin, tra i quali tutti i pin con capacità PWM per il controllo dei servomotori, rispettivamente in posizione 3, 5, 6, 9, 10, 11 e pin 12, 13 e A0 per il controllo del piano resistivo.

\subsection{Servomotori}\label{servomotori}
I servomotori sono l'elemento principale nella realizzazione della piattaforma di Stewart. Sono presenti sei attuatori, controllati in modalità PWM dalla scheda Arduino tramite la libreria \texttt{Servo.h}. L'interpretazione del segnale in ingresso è gestita da un apposito chip di controllo che lo trasforma e lo invia a un motore DC brushless, che tramite un apposito gearbox ad alta riduzione fa ruotare l'asse. La rotazione dell'asse è inoltre recepita dal controllore interno tramite un potenziometro, dando quindi la possibilità di aumentare la coppia se il setpoint non è raggiunto. L'intero sistema è riassunto in figura \ref{fig:servo}. 
\begin{figure}[h!]
\centering
\scalebox{1.1}{
\begin{tikzpicture}[font=\small,thick]

\filldraw  [fill=blue!50](0cm,0cm) rectangle (4cm,3cm);
\filldraw [fill=white](0.25cm,0.25cm) rectangle (1.5cm,2.25cm)node[xshift=-0.625cm, yshift=-1cm]{DC};
\filldraw [fill=black] (2.5cm,2cm) rectangle (3cm,3.5cm);
\filldraw  [fill=white](0.25cm,2.25cm) rectangle (3.75cm,2.75cm)node[xshift=-1.75cm, yshift=-0.25cm]{Gearbox};
\filldraw [fill=white] (2.25cm,2cm) rectangle (3.25cm,1.5cm)node[xshift=-0.5cm, yshift=0.25cm]{Pot.};
\filldraw [fill=white] (2cm,0.25cm) rectangle (3.5cm,1.25cm)node[xshift=-0.75cm, yshift=-0.5cm]{Chip};
\draw [line width=2pt](2,0.5) -- (1.5,0.5);
\draw [line width=2pt](2,1) -- (1.5,1);
\draw [line width=2pt](2.5,1.25) -- (2.5,1.5);
\draw [line width=2pt](2.75,1.25) -- (2.75,1.5);
\draw [line width=2pt](3,1.25) -- (3,1.5);
\draw [line width=2pt](3.5,0.5) -- (7,0.5)node[anchor= south]{GND};
\draw [line width=2pt](3.5,0.75) -- (6,0.75)node[anchor= south]{5V};
\draw [line width=2pt](3.5,1) -- (5,1)node[anchor= south]{Segnale};

\end{tikzpicture}
}
\caption{Componenti del servomotore.} \label{fig:servo}
\end{figure}
A causa del loro elevato rapporto di riduzione questi componenti possono produrre una coppia elevata\footnote{I servomotori impiegati possono sollevare una massa di $3,5kg$ con una manovella di lunghezza nominale $1cm$.}, questo aspetto  non va sottovalutato ed è sempre necessario gestire l'evenienza di uno sforzo durante l'operazione della piattaforma.
Il segnale inviato ai servomotori è periodico, di periodo $20ms$ e presenta uno stato on/off a livello logico per un tempo prefissato a seconda della posizione richiesta. In figura \ref{fig:servocontrol} è descritto il segnale PWM al variare dell'angolo richiesto. 
Il controllo di questi elementi è svolto dal processore tramite uno shield che ne facilita l'installazione. Una nota particolare va fatta in merito alla potenza richiesta dai servomotori, nonostante il loro consumo in stato "idle" sia di circa $10mW$, durante il movimento o lo sforzo questo può superare i $500mW$. É quindi necessaria una alimentazione esterna che sia in grado di fornire almeno $1A$ a $5V$, in quanto la scheda alimentata tramite usb dalla presa del computer può ricevere al massimo $500mA$. Una nota particolare va fatta in merito alla scelta di impiegare servomotori rispetto agli stepper, mentre i primi presentano un posizionamento assoluto, determinato dal segnale PWM e un feedback continuo sulla posizione, i secondi si basano su un posizionamento relativo, sarebbe quindi necessaria un'azione di calibrazione ad ogni accensione del dispositivo, che è preferibile evitare.
\begin{figure}[h!]
\centering
\scalebox{1.1}{
\begin{tikzpicture}[font=\small,thick]
 

\draw [-latex] (0cm,0cm) -- (0cm,1.5cm);
\draw [-latex] (0cm,0cm) -- (5.5cm,0cm)node[anchor= west]{$t$};

\draw [-latex] (0cm,-2cm) -- (0cm,-0.5cm);
\draw [-latex] (0cm,-2cm) -- (5.5cm,-2cm)node[anchor= west]{$t$};

\draw [-latex] (0cm,-4cm) -- (0cm,-2.5cm);
\draw [-latex] (0cm,-4cm) -- (5.5cm,-4cm)node[anchor= west]{$t$};

\draw (0cm,1cm) -- (0.25cm,1cm);
\draw (0cm,-1cm) -- (0.375cm,-1cm);
\draw (0cm,-3cm) -- (0.5cm,-3cm);

\draw (0.25cm,0cm) -- (0.25cm,1cm)node[anchor= west]{$1ms$};
\draw (0.375cm,-2cm) -- (0.375cm,-1cm)node[anchor= west]{$1,5ms$};
\draw (0.5cm,-4cm) -- (0.5cm,-3cm)node[anchor= west]{$2ms$};

\draw (5cm,0.05cm)node[anchor= north]{$20ms$} -- (5cm,-0.05cm);
\draw (5cm,-2.05cm)node[anchor= north]{$20ms$} -- (5cm,-1.95cm);
\draw (5cm,-4.05cm)node[anchor= north]{$20ms$} -- (5cm,-3.95cm);

\filldraw [fill=black] (7,0.75) circle (3pt) node[xshift= -0.75cm] {$0^\circ$};
\filldraw [fill=black] (7,-1.25) circle (3pt) node[xshift= -0.75cm] {$90^\circ$};
\filldraw [fill=black] (7,-3.25) circle (3pt) node[xshift= -0.75cm] {$180^\circ$};

\draw [line width=1mm](7,0.75) -- (7cm,1.75cm);
\draw  [line width=1mm](7,-1.25) -- (8cm,-1.25cm);
\draw [line width=1mm](7,-3.25) -- (7cm,-4.25cm);

\end{tikzpicture}
}
\caption{Angolo del servomotore al variare del PWM.} \label{fig:servocontrol}
\end{figure}

\subsection{Piano resistivo}\label{pianoresistivo}
Per attuare correttamente la stabilizzazione del piano è fondamentale l'impiego di un sistema resistente ai disturbi che sia in grado determinare, con la massima precisione possibile, la posizione della sfera da bilanciare. Questo può essere svolto impiegando diverse tecniche come matrici di laser, rilevazione video o per l'appunto tramite l'uso di un piano resistivo.
É stato scelto di impiegare un digitalizzatore resistivo per il tracking della pallina in quanto è meno soggetto a disturbi ambientali, in particolare da effetti ottici, rispetto alla matrice laser e alla rilevazione video.
Il tracking video avrebbe inoltre richiesto un notevole incremento della complessità del sistema, necessitando di un SOC completo e di software dedicato come OpenCV.
\begin{figure}[h!]
\centering
\scalebox{0.75}{
\begin{tikzpicture}[font=\small,thick]
 

\filldraw [fill=cyan!50](0cm,0cm) rectangle (0.5cm,5cm);
\draw (0.5cm,0cm) rectangle (0.7cm,5cm);
\filldraw[ draw = red!50, very thick, -{Triangle[width=2cm, length= 1cm]}, line width = 1cm] (-4.0,2.5)node[xshift= 1.8cm]{$Pressione$} -- (0.0,2.5);
%\node[single arrow, draw=blue, fill=green, minimum width = 10pt, single arrow head extend=3pt, minimum height=10mm] {}(-4.0cm,2.5cm) to (0.0cm,2.5cm); % length of arrow
\draw (1.5cm,0cm) rectangle (1.75cm,5cm);
\filldraw [fill=cyan!50] (1.75cm,0cm) rectangle (2.25cm,5cm);
\filldraw [fill=black!50](1.5,4.5) arc (90:270:0.75cm);
\filldraw [fill=black!50](1.5,2cm) arc (90:270:0.75cm);
\end{tikzpicture}
}
\caption{Sezione del digitalizzatore resistivo.} \label{fig:sezione}
\end{figure}
\subsubsection{Tipologie e funzionamento di un piano resistivo}\label{tipofunz}
I piani resistivi sono generalmente identificati dal numero di connessioni in uscita, questo può generalmente essere quattro, cinque o otto. La versione a otto fili è una semplice evoluzione della variante a quattro e non sarà trattata in dettaglio. Questi dispositivi sono costituiti da due strati, di vetro o plastica, ricoperti da un sottile strato di ossido di indio-stagno\footnote{Materiale scelto appositamente per le ottime proprietà di trasparenza e conduzione.} e separati da minuscoli spaziatori, come rappresentato in figura \ref{fig:sezione}. 
La resistenza del conduttore è uniforme su tutta la superficie e alla pressione si forma un contatto tra i due strati che permette un passaggio di corrente. A seconda del punto di pressione si formerà un rapporto di partizione diverso, indicativo della posizione.
Nella versione a quattro fili su entrambi i piani si forma un gradiente di potenziale nelle direzioni rispettivamente \emph{x} e \emph{y} e ognuno dei due misura il potenziale dell'altro. Nella versione a cinque invece si ha un piano su cui viene alternata la direzione del gradiente mentre l'altro effettua la misura.\cite{pianoresistivo} Il valore di tensione letto sarà quindi inviato all'ADC della scheda Arduino, che effettuerà una quantizzazione a $10bit$, restituendo un valore da $0$ a $1023$, poi convertito in una posizione effettiva.
Nella realizzazione del progetto è stata impiegata la variante di piano resistivo a cinque cavi.
\begin{figure}[h!]
\centering
\scalebox{0.3}{

\begin{circuitikz}[ultra thick]
\node[anchor=south west,inner sep=0] at (0,0) {\includegraphics{5wire.png}};
 %\draw[red,ultra thick,rounded corners] (7.5,5.3) rectangle (9.4,6.2);

\scalebox{2}{
\draw [red, line width=2pt]
	(9.5,3) to[R,color=red] (11,4.5)
	(11,4.5) to[R,color=red] (12.5,6)
	(12.5,6) -- (14,6)
;
}
\end{circuitikz}
}
\caption{Schematica circuitale piano resistivo a cinque fili.} \label{fig:controllo}
\end{figure}

\subsection{Ponte ad H}\label{hbridge}
La necessità di impiegare un ponte ad H come circuito di driver è emersa in seguito ad una analisi preliminare delle specifiche del digitalizzatore resistivo. Si è infatti notato, in seguito a una misura di resistenza, che questa fosse di soli $100 \Omega$, quindi non compatibile con le periferiche dell'Arduino UNO, in quanto a $5V$ si andrebbe a richiamare una corrente di $50mA$ mentre la scheda è in grado di fornirne solo $20$. L'impiego del ponte ad H ed una sorgente di alimentazione esterna stabilizzata permette di pilotare opportunamente il piano tramite l'uso dispositivi attivi come BJT o MOSFET. Non disponendo del componente finito si è scelto di realizzarlo a partire dai singoli chip in seguito ad un'analisi accurata tramite software SPICE (figura \ref{fig:controllo}) e basandosi sul datasheet del ponte L298N.\cite{l298n} Nella scelta della tecnologia da impiegare sono stati preferiti i MOSFET per via della caduta di tensione Drain-Source quasi nulla nello stato di conduzione dovuta a una bassissima resistenza interna. 
\begin{figure}[h!]
\centering
\scalebox{0.30}{
\includegraphics{circuito.png}
}
\caption{Schematica circuito di controllo.} \label{fig:controllo}
\end{figure}
I MOSFET scelti sono degli AO3400 e A03401, rispettivamente nella configurazione n e p in quanto offrono ottime prestazioni relativamente alla $I_D$ e alla $R_{DS}$.\cite{ao3400}\cite{ao3401} Da un'analisi del sistema di controllo richiesto dal piano resistivo si è deciso di rinunciare alla capacità di gestire individualmente i singoli MOSFET favorendo due linee di controllo che possano commutare tra gli stati High/Low. Sono state inoltre impiegate delle porte logiche NAND con lo scopo di migliorare il pilotaggio dei MOSFET da parte di Arduino oltre che per disaccoppiare la logica di controllo dallo stadio di potenza, pratica comune anche nel caso del L298N. Come chip per le porte NAND si è scelto un TC4011BP, questo fornisce in un singolo package quattro porte logiche che sono state configurate come invertenti in cascata, principalmente per una questione di convenienza, nel caso in cui si fosse reso necessario impiegare il segnale negato.\cite{TC4011BP} É stata poi inserita una resistenza di $1\Omega$ verso ground per limitare la corrente di shoot-through durante la commutazione. Da una successiva analisi all'oscilloscopio si è constatato che questi impulsi di corrente, estremamente brevi, rientravano perfettamente nelle specifiche dei MOSFET impiegati.

\subsection{Joystick analogico}\label{joystick}
Per facilitare e rendere più intuitivo il controllo del sistema è stato impiegato un joystick analogico. Questo dispositivo è costituito da due potenziometri montati ortogonalmente negli assi $x$ e $y$ e da un piccolo switch momentaneo. I segnali analogici generati dai due potenziometri vengono digitalizzati dall'ADC del processore mentre l'interruttore viene letto dall'input digitale. Tramite questi dati sarà possibile avere un controllo diretto del piano ed assegnale dei setpoint in maniera arbitraria.%inviare diversi comandi al sistema ed avere una gestione indipendente dal pc, slegandosi dall'assegnazione esclusiva tramite seriale.

\newpage

\section{Piattaforma di Gough-Stewart}\label{pianostewart}



\subsection{Descrizione}\label{piattaformastewart}
La piattaforma di Gough-Stewart è un particolare sistema meccanico, realizzato per la prima volta nel 1954 dall'ingegnere britannico E. Gough e successivamente portata alla notorietà tramite la pubblicazione di un paper nel 1965 da parte di D. Stewart dal titolo "A Platform with Six Degrees of Freedom". Questo è descritto come un robot esapode, ovvero costituito da una base su cui sono posizionati sei attuatori di vario tipo collegati alla piattaforma superiore mediante giunti snodabili. Il progetto originale prevedeva l'uso di attuatori prismatici, ovvero pistoni lineari che presentano un solo grado di libertà, offrendo numerose proprietà relative alla precisione a alla stabilità. Nel progetto vengono impiegati servomotori che presentano il vantaggio di essere certamente più economici rispetto agli attuatori prismatici ma il sistema risultante assume un grado di complessità superiore. Tramite opportune osservazioni matematiche è possibile risalire a un modello che rende equivalente l'impiego di attuatori rotativi a quello dei lineari, garantendo un range di movimento ottimale.

\subsection{Robot seriali e paralleli}\label{robotserialiparalleli}
È utile enunciare la differenza tra robot di tipo seriale e parallelo per comprendere le successive implicazioni a livello matematico. I robot seriali prevedono una serie di giunti snodabili controllati da attuatori, che spesso assumono le caratteristiche di un arto antropomorfo. 
Questi tipi di robot prendono spesso il nome di braccio meccanico e trovano ampia applicazione a livello industriale.
Nei robot paralleli invece, gli attuatori agiscono tutti sullo stesso elemento tramite giunti indipendenti. 
La piattaforma di Stewart ne è il principale esempio e trova applicazione soprattutto nella realizzazione di simulatori avanzati di volo o per testare veicoli nelle case automobilistiche.\footnote{Si nota come i delta-robot siano sostanzialmente delle versioni "limitate" della piattaforma di Stewart a soli 3 gradi di libertà.}
Entrambi i sistemi presentano 6 gradi di libertà, indicati anche come $6DOF$, ma il problema matematico che li caratterizza è fondamentalmente opposto.
\begin{figure}
\centering
\scalebox{1}{
\begin{tikzpicture}[font=\small,thick]
 
\node[draw,
    minimum width=2cm,
    minimum height=1cm,
    text width=2cm, text centered
] (block1) {Sistema};

\draw [-latex] (-2cm,0cm)node[anchor=east]{$(\vartheta_1,\vartheta_2,...,\vartheta_n)$} -- (block1);
\draw [-latex] (block1) -- (2cm,0cm)node[anchor=west]{$(x,y,z,\varphi,\vartheta,\psi)$};
\draw node[yshift=-2cm,xshift=-3.5cm]{$(x,y,z,\varphi,\vartheta,\psi)=S(\vartheta_1,\vartheta_2,...,\vartheta_n)$};
\draw node[yshift=-1.25cm,xshift=0cm]{Problemi:};
\draw node[yshift=-2.5cm,xshift=-3.5cm]{Diretto};
\draw node[yshift=-2cm,xshift=3.5cm]{$(\vartheta_1,\vartheta_2,...,\vartheta_n)=S(x,y,z,\varphi,\vartheta,\psi)$};
\draw node[yshift=-2.5cm,xshift=3.5cm]{Inverso};

\end{tikzpicture}
}
\caption{Problemi diretti e inversi.} \label{fig:direttoinverso}
\end{figure}
Lo schema logico dei problemi diretti e inversi è indicato in figura \ref{fig:direttoinverso}, dove $(\vartheta_1,\vartheta_2,...,\vartheta_n)$ indicano gli angoli dei servomotori e $(x,y,z,\varphi,\vartheta,\psi)$ la posizione dell'end-effector.
Se nei robot seriali, noto l'orientamento degli attuatori, è facile risalire alla posizione dell'end effector; lo stesso non si può dire del problema inverso. Nota la posizione dell'end effector è infatti estremamente difficile risalire all'orientamento degli attuatori che permette raggiungere quella determinata locazione. Il problema della piattaforma di Stewart è esattamente l'opposto, è molto difficile ottenere equazioni che ci permettano di descrivere le coordinate e la rotazione del piano al variare dell'angolo dell'attuatore rotativo, è invece molto facile risalire all'angolo dei servomotori a partire dalla posizione nota della piattaforma nello spazio impiegando semplici nozioni di trigonometria. Basti pensare che la soluzione diretta del problema prevede la risoluzione di un sistema di 30 equazioni nonlineari risolvibili in forma chiusa che possono arrivare ad avere fino a un massimo di 40 possibili soluzioni.\cite{cinematicadiretta2} Queste nozioni di cinematica sono riassunte nella tabella \ref{fig:tabella}.
\begin{table}[h!]
\centering
\begin{tabular}{c|cc}
        & Seriale   & Parallelo  \\ 
\hline
Diretto & Facile    & Difficile  \\
Inverso & Difficile & Facile    
\end{tabular}
\caption{Difficoltà problemi diretti e inversi} \label{fig:tabella}
\end{table}
Nello svolgimento successivo si è preferito risalire alle equazioni della cinematica inversa della piattaforma di Stewart in quanto le dirette non sono necessarie ai fini dello svolgimento e richiederebbero inoltre un carico eccessivo da parte del microprocessore.



\subsection{Analisi piattaforma di Stewart con attuatori rotativi}\label{analisi}

Il problema della piattaforma di Stewart controllata da attuatori rotativi è fondamentalmente costituito da due sotto-problemi.
Il primo relativo alla determinazione delle lunghezze dei vettori che collegano la base alla piattaforma per ogni possibile posizione, trattato nella sezione \ref{platform}. Il secondo si occupa invece dell'implementazione stessa dei servomotori, per via della complessità di descrizione del sistema biella manovella impiegato, trattato nella sezione \ref{rotation}. 

\subsection{Analisi problema piattaforma}\label{platform}

Si definiscono due sistemi di riferimento cartesiani che caratterizzano il sistema, mostrati nella figura \ref{fig:sistema}, uno fisso per la base centrato in $O$ di versori $\hat{i},\hat{j},\hat{k}$ e uno variabile per la piattaforma centrato in $O'$ di versori $\hat{i'},\hat{j'},\hat{k'}$. Sono note le coordinate in tre dimensioni dei punti degli assi di rotazione dei servomotori $({B_i})$ e dei giunti della piattaforma $(P_i)$ quando questa è in posizione orizzontale a riposo rispetto al sistema di riferimento centrato nella base. Il problema consiste nel definire la posizione dei giunti della piattaforma nello spazio al variare di un set di valori $(x,y,z,\varphi,\vartheta,\psi)$ rispetto al riferimento fisso della base. I valori $(x,y,z,\varphi,\vartheta,\psi)$ precedentemente enunciati, si riferiscono alla posizione e rotazione nello spazio della piattaforma rispetto alla base; $(x,y,z)$ sono i valori del centro della piattaforma mentre $(\varphi,\vartheta,\psi)$ sono le rotazioni, rispettivamente roll, pitch e yaw (rollio, beccheggio e imbardata). Nell'analisi, si considerano separatamente gli effetti traslativi e rotativi.

\begin{figure}
\centering

\scalebox{0.9}{
\begin{tikzpicture}

\filldraw[fill=yellow!50,rotate around={-10:(0,7cm)},xshift=2cm,yshift=1cm] (0,7cm) ellipse (4cm and 2cm);
\filldraw [fill=red!50](0,0) ellipse (5cm and 2.5cm);
\draw [-latex, thick] (0,0) -- node[anchor=south]{$\hat b_i$}(5cm,0);
\draw [-latex, thick] (0,0) -- node[anchor=east]{$\hat T$}(2.15cm,7.65cm);
\draw [-latex, thick] (0,0) -- node[anchor=north]{$\hat q_i$}(6.1cm,6.95cm);
\draw [-latex, thick] (5cm,0) -- node[anchor=west]{$\hat l_i$}(6.1cm,6.95cm);
\draw[-latex, thick,rotate around={-10:(0,7cm)},xshift=2cm,yshift=1cm] (0cm,7cm) -- node[anchor=south]{$\hat p_i$}(4cm,7cm);
\filldraw [fill=black] (0,0) circle (2pt) node[yshift= -0.25cm] {$O$} node[xshift= -2cm] {Base};
\filldraw [fill=black] (5cm,0) circle (2pt) node[anchor=west]{$B_i$};
\filldraw [fill=black] (2.15cm,7.65cm) circle (2pt) node[yshift= 0.25cm] {$O'$} node[xshift= -2cm] {Piattaforma};
\filldraw [fill=black] (6.1cm,6.95cm) circle (2pt) node[anchor=west]{$P_i$};
\draw [-latex, thick] (-1,-1.5) -- node[anchor=north]{$\hat i$}(0cm,-1.5cm);
\draw [-latex, thick] (-1,-1.5) -- node[anchor=east]{$\hat k$}(-1cm,-0.5cm);
\draw [-latex, thick,rotate around={-120:(-1,-1.5cm)}] (-1,-1.5) -- node[anchor=east]{$\hat j$}(-0.5cm,-1.5cm);

\draw [-latex, thick,rotate around={-10:(0,8.5cm)}] (0,8.5) -- node[anchor=north]{$\hat {i'}$}(1cm,8.5cm);
\draw [-latex, thick,rotate around={-10:(0,8.5cm)}] (0,8.5) -- node[anchor=east]{$\hat {k'}$}(0cm,9.5cm);
\draw [-latex, thick,rotate around={-130:(0,8.5cm)}] (0,8.5) -- node[anchor=east]{$\hat {j'}$}(0.5cm,8.5cm);

\end{tikzpicture}
}
\caption{Sistemi di rifermento e vettori nel piano di Stewart.} \label{fig:sistema}
\end{figure}


\subsubsection{Analisi traslazione \boldmath$(x,y,z)$}\label{xyz}
Le variazioni in $(x,y,z)$ comportano una semplice traslazione dei punti della piattaforma, questa viene indicata con un vettore $\hat T$ che andrà poi a sommarsi alla variazione dovuta a $(\varphi,\vartheta,\psi)$.

\subsubsection{Analisi rotazione \boldmath$(\varphi,\vartheta,\psi)$}\label{ftp}
Per semplificare l'analisi si considerano, separatamente, gli effetti dovuti a queste tre componenti. Si studia il caso di solo rollio $(\varphi,0,0)$ per risalire alle coordinate di un punto $P:(x,y,z)$ rispetto alla base in seguito a una rotazione di $\varphi$ gradi che lo ha traslato nel punto $(x',y',z')$, come rappresentato in figura \ref{fig:rot}. Per fare ciò, è necessario ottenere un'applicazione lineare che permetta di passare dal sistema di coordinate della piattaforma al sistema di coordinate della base.

\begin{figure}
\centering
\scalebox{1.2}{
\begin{tikzpicture}
\draw [-latex](0,0) -- (4cm,0)node[anchor=north]{$\hat{j}$};
\draw [-latex](0,0) -- (0,4cm)node[anchor=east]{$\hat{k}$};

\draw [-latex,rotate around={30:(0,0cm)}](0,0) -- (4cm,0)node[anchor=south]{$\hat{j'}$};
\draw [-latex,rotate around={30:(0,0cm)}](0,0) -- (0,4cm)node[anchor=east]{$\hat{k'}$};

\draw [rotate around={60:(0,0cm)}](0,0) -- (3cm,0)node[anchor=south]{$\hat{P}$};

\draw (0,0)node[xshift= 1.25cm,yshift= 0.25cm]{$\varphi$} -- (10mm,0mm) arc  (0:30:10mm)-- cycle;
\filldraw [-latex,fill=black] (0cm,0cm) circle (2pt) node[xshift=-0.25cm,yshift=-0.25cm]{$\hat{i}$};
\filldraw [-latex,fill=black] (1.5cm,2.6cm) circle (2pt);
\draw [dashed,rotate around={30:(0,0cm)}](2.6cm,0cm) -- (2.6cm,1.5cm);
\draw [dashed,rotate around={30:(0,0cm)}](0cm,1.5cm) -- (2.6cm,1.5cm);

\draw (1.5cm,2.6cm)node[xshift= 0.5cm,yshift= -0.3cm]{$\varphi$} -- (1.5cm,2.1cm) arc  (270: 300:5mm)-- cycle;

\draw [dashed](1.5cm,0cm) -- (1.5cm,2.6cm);
\draw [dashed](0cm,2.6cm) -- (1.5cm,2.6cm);

\end{tikzpicture}
}
\caption{Vettore $\hat{P}$ ruotato di $\varphi$ gradi rispetto alla base.} \label{fig:rot}
\end{figure}

Dallo studio della rotazione troviamo che:

\begin{equation}\label{sistema1}
\begin{cases} 
x=x' \\ 
y=y'cos(\varphi)-z'sin(\varphi) \\ 
z=y'sin(\varphi)-z'cos(\varphi)
\end{cases} 
\end{equation}


Per comodità di calcolo nei successivi passaggi il sistema \eqref{sistema1} viene riscritto in forma matriciale.

\begin{equation}\label{rx}
R_x(\varphi)=
\begin{bmatrix}
1 & 0 & 0\\
0 & cos(\varphi) & -sin(\varphi)\\
0 & sin(\varphi) & cos(\varphi)
\end{bmatrix}
\quad : \quad
\begin{bmatrix}
x \\
y \\
z 
\end{bmatrix}
=R_x(\varphi)\cdot\begin{bmatrix}
x' \\
y' \\
z' 
\end{bmatrix}
\end{equation}
Risultati analoghi si ottengono per le rotazioni indipendenti di $\vartheta$ e $\psi$:
\begin{equation}\label{ry}
R_y(\vartheta)=
\begin{bmatrix}
cos(\vartheta) & 0 & sin(\vartheta)\\
0 & 1 & 0\\
-sin(\vartheta) & 0 & cos(\vartheta)
\end{bmatrix}
\quad : \quad
\begin{bmatrix}
x \\
y \\
z 
\end{bmatrix}
=R_y(\vartheta)\cdot\begin{bmatrix}
x' \\
y' \\
z' 
\end{bmatrix}
\end{equation}
\begin{equation}\label{rz}
R_z(\psi)=
\begin{bmatrix}
cos(\psi) & -sin(\psi) & 0\\
sin(\psi) & cos(\psi) & 0\\
0 & 0 & 1\\
\end{bmatrix}
\quad : \quad
\begin{bmatrix}
x \\
y \\
z 
\end{bmatrix}
=R_z(\psi)\cdot\begin{bmatrix}
x' \\
y' \\
z' 
\end{bmatrix}
\end{equation}

Le singole matrici possono essere viste come applicazioni lineari, si procede quindi nella moltiplicazione di \eqref{rx}, \eqref{ry} e \eqref{rz} per ottenere una singola applicazione lineare composta detta matrice di rotazione globale $R_g$. Notare che nel prodotto tra matrici non vale la proprietà commutativa, bisogna quindi valutare attentamente l'ordine di moltiplicazione, altrimenti si otterrà una rotazione erronea. I passaggi intermedi vengono omessi in quanto ripetono tre volte una semplice operazione di moltiplicazione tra matrici.

\begin{equation}\label{rg}
    R_g = R_z(\psi)\cdot R_y(\vartheta)\cdot R_x(\varphi)\\
\end{equation}
Il cui risultato è quindi:
\begin{equation}\label{rg}
\resizebox{0.9\hsize}{!}{$
\begin{bmatrix}
			cos(\vartheta)cos(\psi) & -cos(\varphi)sin(\psi)+sin(\varphi)sin(\vartheta)cos(\psi) & sin(\varphi)sin(\psi)+cos(\varphi)sin(\vartheta)cos(\psi)\\
			cos(\vartheta)sin(\psi) & cos(\varphi)cos(\psi)+sin(\varphi)sin(\vartheta)sin(\psi) & -sin(\varphi)cos(\psi)+cos(\varphi)sin(\vartheta)sin(\psi)\\
			-sin(\vartheta) & sin(\varphi)cos(\vartheta) & cos(\varphi)cos(\vartheta)
			\end{bmatrix}$}
\end{equation}

Moltiplicando il vettore $\hat{p_i}$, che congiunge il centro della piattaforma al giunto, per la matrice di rotazione \eqref{rg} si ottengono le coordinate del punto $P_i$ relative al sistema di riferimento della base. 

\subsubsection{Conclusione problema piattaforma}
Grazie ai risultati ottenuti nelle sezioni \ref{xyz} e \ref{ftp} si possono definire i vettori $\hat{q_i}$ che descrivono la posizione dei punti $P_i$ rispetto al centro del sistema di riferimento della base $O$ per ogni operazione rototraslativa.
\begin{equation}\label{qi}
\hat{q_i}=\hat{T}+R_g\cdot \hat{p_i}
\end{equation}
Una volta ottenuto questo vettore, con una semplice operazione vettoriale, si può risalire a $\hat{l_i}$, vettore che descrive la distanza tra l'asse del servomotore e il corrispettivo giunto sulla piattaforma.

\begin{align}\label{li}
\hat{l_i}=\hat{T}+R_g\cdot \hat{p_i}-\hat{b_i}
\end{align}
Nel caso della piattaforma di Stewart, sei equazioni \eqref{li} permettono di descrivere la posizione della piattaforma al variare di $(x,y,z,\varphi,\vartheta,\psi)$.
Notare come, nel caso di impiego di attuatori lineari, il problema si risolve assegnando direttamente queste lunghezze per ottenere la posizione desiderata. 

\subsection{Analisi problema attuatori rotativi}\label{rotation}
L'impiego di servomotori complica ulteriormente le equazioni, è infatti necessario un numero di variabili superiore per descrivere in modo appropriato il sistema. Ogni servomotore controlla un giunto biella manovella collegato alla piattaforma che regola la lunghezza del vettore $\hat{l_i}$, fondamentale è quindi trovare una relazione tra l'angolo del servomotore e il vettore $\hat{l_i}$. Anche in questo caso la soluzione si ottiene dalla scomposizione del problema in due parti: la determinazione della posizione del giunto biella manovella e la ricerca dell'angolo di rotazione $\alpha$ svolta rispettivamente nelle sezioni \ref{biellamanovella} e \ref{determinazionealfa}.

\begin{figure}[h!]
\centering
\scalebox{1.2}{
\begin{tikzpicture}
\filldraw [fill=blue!50](1cm,0cm) rectangle (2,2);
\filldraw [fill=black] (1.5cm,1.5cm) circle (3pt);
\filldraw [fill=blue!50](-1cm,0cm) rectangle (-2,2);
\filldraw [fill=black] (-1.5cm,1.5cm) circle (3pt);
\filldraw  [fill=black!50](-3cm,0cm) rectangle (3cm,-0.25cm);
\filldraw  [fill=black!50](-3cm,2cm) rectangle (3cm,2.25cm);
\draw  (1.5cm,1.5cm) -- node[anchor=south, xshift= 0cm,yshift=-0.45cm]{$m$}(3cm,0.75cm);
\draw  (3cm,0.75cm) -- node[anchor=west]{$b$}(4cm,7cm);
\draw  (-1.5cm,1.5cm) -- (-3cm,0.75cm);
\draw  (-3cm,0.75cm) -- (-4cm,7cm);
\filldraw  [fill=black!50]  (-4cm,7cm) rectangle (4cm,7.25cm);
%\draw [line width=2pt] (1cm,3cm) -- node[anchor=east, xshift= 0.6cm,yshift=-0.45cm]{$m$}(3cm,2cm);
%\filldraw [fill=black] (3cm,2cm) circle (3pt);
%\filldraw [fill=black] (2cm,9cm) circle (3pt);
%\draw [line width=2pt] (3cm,2cm) -- node[anchor=west]{$b$}(2cm,9cm);
\draw [dashed] (1.5cm,1.5cm) -- node[anchor=east]{$l$}(4cm,7cm);
\draw [dashed] (-1.5cm,1.5cm) -- (-4cm,7cm);
%\draw [<->] (3.5cm,2.2cm) arc (150:125:33.7pt);
\filldraw [fill=black] (-3cm,0.75cm) circle (1.5pt);
\filldraw [fill=black] (3cm,0.75cm) circle (1.5pt);
\filldraw [fill=black] (-4cm,7cm) circle (1.5pt);
\filldraw [fill=black] (4cm,7cm) circle (1.5pt);
\draw (-2.5cm,1.5cm) arc (-180:-158:1.2cm)node[anchor=east, yshift=0.2cm, xshift=-0.1cm]{$\alpha$};
\draw [dashed] (-1.5cm,1.5cm) -- (-2.5cm,1.5cm);
\end{tikzpicture}
}
\caption{Sistema biella manovella con servomotori in proiezione frontale.} \label{fig:rv}
\end{figure}

\subsubsection{Posizione del giunto biella manovella}\label{biellamanovella}
Note le lunghezze della biella $b$ e della manovella $m$, si valuta l'angolo di inclinazione dei servomotori rispetto all'asse $x$ e si indica con $\beta$, come in figura \ref{fig:proiezioneverticale}, notando come i servomotori siano a due a due specchiati. Due set di equazioni saranno quindi necessarie per descrivere i motori pari e dispari al variare di $\alpha$.
\begin{equation}\label{bmpari}
    \begin{cases}
      x_{bm}=m \cdot cos(\alpha)cos(\beta)+x_b\\
      y_{bm}=m \cdot cos(\alpha)sin(\beta)+y_b\\
      z_{bm}=m \cdot sin(\alpha)+z_b\\
    \end{cases}\quad pari
\end{equation}
\begin{equation}\label{bmdispari}
    \begin{cases}
      x_{bm}=m \cdot cos(\alpha)cos(\pi+\beta)+x_b\\
      y_{bm}=m \cdot cos(\alpha)sin(\pi+\beta)+y_b\\
      z_{bm}=m \cdot sin(\alpha)+z_b\\
    \end{cases}\quad dispari
\end{equation}
Applicando le nozioni trigonometriche: 
$$cos(\alpha)=-cos(\alpha) \quad cos(\pi+\beta)=-cos(\beta) \quad sin(\pi+\beta)=-sin(\beta)$$
ai sistemi \eqref{bmpari} e \eqref{bmdispari} risulta evidente che questi due sono equivalenti.
\begin{figure}[h!]
\centering
\scalebox{1.2}{
\begin{tikzpicture}[font=\small,thick]
\node[fill=black!50,regular polygon, regular polygon sides=6, shape aspect=0.5, minimum width=5cm, minimum height=1cm, draw, rotate around={30:(0,0cm)}] (reg) {};
\draw [-latex](-3,0) -- (3,0cm)node[anchor=south]{$x$};
\filldraw [fill=blue!50, rotate around={0:(0,0cm)}](-1.3cm,0.3cm) rectangle (-2.165,0.9)node[xshift=-1cm]{$\beta=\frac{\pi}{2}$};
\filldraw [fill=blue!50, rotate around={0:(0,0cm)}](-1.3cm,-0.3cm) rectangle (-2.165,-0.9)node[xshift=-1cm]{$\beta=-\frac{\pi}{2}$};
\filldraw [fill=blue!50, rotate around={120:(0,0cm)}](-1.3cm,0.3cm) rectangle (-2.165,0.9)node[xshift=1.25cm]{$\beta=\frac{\pi}{6}$};
\filldraw [fill=blue!50, rotate around={120:(0,0cm)}](-1.3cm,-0.3cm) rectangle (-2.165,-0.9);
\filldraw [fill=blue!50, rotate around={240:(0,0cm)}](-1.3cm,0.3cm) rectangle (-2.165,0.9);
\filldraw [fill=blue!50, rotate around={240:(0,0cm)}](-1.3cm,-0.3cm) rectangle (-2.165,-0.9)node[xshift=1.25cm]{$\beta=\frac{5\pi}{6}$};
\end{tikzpicture}
}
\caption{Proiezione verticale della base con i servomotori.} \label{fig:proiezioneverticale}
\end{figure}
\subsubsection{Determinazione angolo \boldmath$\alpha$}\label{determinazionealfa}
Per la determinazione dell'angolo $\alpha$ ottimale esistono due tecniche principali. La prima consiste in una ricerca binaria (o dicotomica) del valore che meglio soddisfa le equazioni della posizione. La seconda prevede un approccio matematico più estensivo per determinare il valore \textbf{esatto} di $\alpha$ in base ad una $l$ fornita.\cite{calcolostewart1}\cite{calcolostewart2} Il primo approccio risulta più semplice dal punto di vista realizzativo ma a suo discapito è poco efficiente, in quanto richiede un numero arbitrario di iterazioni per raggiungere una determinata precisione di $\alpha$.\footnote{Mediamente un algoritmo di ricerca binaria assume una complessità \emph{O(log n)}, dove \emph{n} è direttamente correlato alla precisione del valore ottenuto.} Il secondo è invece più difficile da ottenere a causa dei calcoli non del tutto intuitivi ma garantisce di raggiungere la soluzione ottimale con una sola computazione. Per lo svolgimento del progetto è stata impiegata la seconda opzione, che prevede da ricerca di un valore di $\alpha$ che soddisfi le equazioni \eqref{m2}, \eqref{l2} e \eqref{b2} ottenute dal teorema di Pitagora in tre dimensioni.
\begin{align}\label{m2}
    m^2 &= (x_{bm}-x_b)^2+(y_{bm}-y_b)^2+(z_{bm}-z_b)^2\nonumber\\
    		&= (x_{bm}^2+y_{bm}^2+z_{bm}^2)+(x_{b}^2+y_{b}^2+z_{b}^2)-2(x_{bm}x_b+y_{bm}y_b+z_{bm}z_b)
\end{align}
\begin{align}\label{l2}
    l^2 &= (x_{q}-x_b)^2+(y_{q}-y_b)^2+(z_{q}-z_b)^2\nonumber\\
    		&= (x_{q}^2+y_{q}^2+z_{q}^2)+(x_{b}^2+y_{b}^2+z_{b}^2)-2(x_{q}x_b+y_{q}y_b+z_{q}z_b)
\end{align}
\begin{align}\label{b2}
    b^2 &= (x_{q}-x_{bm})^2+(y_{q}-y_{bm})^2+(z_{q}-z_{bm})^2\nonumber\\
    		&= (x_{q}^2+y_{q}^2+z_{q}^2)+(x_{bm}^2+y_{bm}^2+z_{bm}^2)-2(x_{q}x_{bm}+y_{q}y_{bm}+z_{q}z_{bm})
\end{align}
I valori di $m^2$, $l^2$ e $b^2$ sono noti, si sostituiscono le equazioni \eqref{m2} e \eqref{l2} in \eqref{b2}, si ottiene:
\begin{align}\label{passaggio}
    l^2-(b^2-m^2) =& 2(x_{b}^2+y_{b}^2+z_{b}^2)+2x_{bm}(x_q-x_b)+2y_{bm}(y_q-y_b)\nonumber \\&+2z_{bm}(z_q-z_b)-2(x_qx_b+y_qy_b+z_qz_b)
\end{align}
Si sostituiscono le equazioni dei valori noti $x_{bm}$, $y_{bm}$ e $z_{bm}$ calcolate in \eqref{bmpari} e si svolgono le dovute semplificazioni.
\begin{align}\label{passaggio}
    l^2-(b^2-m^2) =& 2(x_{b}^2+y_{b}^2+z_{b}^2)+2[m \cdot cos(\alpha)cos(\beta)+x_b](x_q-x_b)\nonumber\\
    &+2[m \cdot cos(\alpha)sin(\beta)+y_b](y_q-y_b)
    \nonumber\\ &+2[m \cdot sin(\alpha)+z_b](z_q-z_b)-2(x_qx_b+y_qy_b+z_qz_b)\nonumber\\
    				   =& 2m \cdot cos(\alpha)cos(\beta)(x_q-x_b)\nonumber\\&+2m \cdot cos(\alpha)sin(\beta)(y_q-y_b)\nonumber\\
    				   & +2m \cdot sin(\alpha)(z_q-z_b)\nonumber\\
    				   =& 2m \cdot sin(\alpha)(z_q-z_b) \nonumber\\
    				   &+2m \cdot cos(\alpha)[cos(\beta)(x_q-x_b)+sin(\beta)(y_q-y_b)]   
\end{align}
L'equazione \eqref{passaggio} è nella forma $L=Mcos(\alpha)+Nsin(\alpha)$ e può essere ulteriormente compattata considerando la formula della somma di segnali sinusoidali di diversa ampiezza, secondo la quale un segnale $Acos(\alpha)+Bsin(\alpha)$ può essere riscritto come $Csin(\alpha + \nu)$, infatti:
\begin{equation}\label{c}
Csin(\alpha + \nu)=Csin(\alpha)\cdot cos(\nu)+Ccos(\alpha)\cdot sin(\nu)\nonumber
\end{equation}
\begin{equation}\label{tg}
    \begin{cases}
      A=Ccos(\nu)\\
      B=Csin(\nu)\\
    \end{cases}\quad \Rightarrow \quad  C=\sqrt{A^2+B^2}, \quad \nu=arctan\left(\frac{B}{A}\right)
\end{equation}

Applicando il risultato ottenuto in \eqref{tg} possiamo quindi scrivere:
\begin{align}\label{alfa}
    L= \sqrt{M^2+N^2}\cdot sin\left(\alpha+arctan\left(\frac{N}{M}\right)\right) \quad  &\Rightarrow\nonumber\\ sin\left(\alpha+arctan\left(\frac{N}{M}\right)\right)=\frac{L}{\sqrt{M^2+N^2}}  \quad  &\Rightarrow\nonumber\\
    \alpha=arsin\left(\frac{L}{\sqrt{M^2+N^2}}\right)-arctan\left(\frac{N}{M}\right)
\end{align}
Con rispettivamente:
\begin{equation}\label{lnm}
L=l^2-(b^2-m^2), \quad M=2m(z_q-z_b), \quad N=2m[cos(\beta)(x_q-x_b)+sin(\beta)(y_q-y_b)]
\end{equation}
Si conclude così la ricerca dell'angolo $\alpha$.

\subsubsection{Controllo servomotori}
Al fine di controllare i servomotori in modo ottimale è necessario effettuare alcuni accorgimenti.
É necessario definire un'altezza $h_0$ e un angolo $\alpha_0$ di riposo dei servomotori, questo è scelto in modo che le manovelle dei servomotori siano orizzontali, quindi $\alpha_0=0^\circ$, l'altezza è ricavata sperimentalmente valutando per quale valore di $h$ i servomotori lavorano in modo speculare in seguito all'assegnazione delle varie rotazioni.
Siccome i servomotori hanno caratteristiche variabili a seconda del produttore bisogna definire una relazione tra la variazione in $\mu s$ del segnale PWM e la variazione dell'angolo $\alpha$ in radianti. Notare inoltre come questa relazione non valga quando il servomotore si trova vicino alla massima escursione, per avere una misura accurata analizziamo la relazione tra $\mu s$ e la rotazione $\alpha$ dalla posizione orizzontale a 45° con il seguente rapporto:
\begin{align}\label{rel}
r &=\frac{\Delta t}{\Delta\alpha}\cdot \frac{360^\circ}{2 \pi}\nonumber\\
	&= \frac{375}{45^\circ}\cdot \frac{360^\circ}{2 \pi} \quad [\mu s/rad]
\end{align}
Il cui risultato è stato ottenuto sperimentalmente impiegando il valore $\Delta t = 375 \mu s$. In questo modo moltiplicando un angolo $\alpha$ per la \eqref{rel} otteniamo i corrispettivi $\mu s$ da assegnare al servomotore. Si possono quindi scrivere le equazioni di controllo per i servomotori, distinguendo sempre tra pari e dispari.
\begin{equation}\label{w}
    \begin{cases}
      w_i=w_i^0 +(\alpha_i-\alpha_0)\cdot r	\quad pari \\
      w_i=w_i^0 +(\alpha_i-\alpha_0)\cdot r	\quad dispari \\
    \end{cases}
\end{equation}
Dove $w_i^0$ indicano le posizioni a riposo dei servomotori in $\mu s$.
Per migliorare la sicurezza del sistema è stato introdotto un controllo degli angoli assegnati ai servomotori, in modo da evitare possibili conflitti meccanici.
Il sistema di controllo analizza tutti i valori di $w_i$ prima che questi siano assegnati ai servomotori, li confronta con un range di valori accettabili e verifica che non siano valori impossibili (\texttt{NaN}).
Se le condizioni sono rispettate procede assegnando i valori, altrimenti entra in una routine di allarme e blocca il sistema. Il funzionamento globale del sistema è riassunto nello schema a blocchi presente nella sezione \ref{schemablocchi}.

\subsection{Schema a blocchi}\label{schemablocchi}
Questo schema logico descrive in modo riassuntivo il controllo della piattaforma di Stewart con attuatori rotativi, nonché gli accorgimenti necessari a rendere il sistema più sicuro in caso di valori di ingresso errati.

\begin{figure}[h!]
\centering
\scalebox{0.9}{
\begin{tikzpicture}[font=\small,thick]
 
% Start block
\node[draw,
    rounded rectangle,
    minimum width=2.5cm,
    minimum height=1cm, text width=5cm, text centered] (block1) {Caratteristiche piattaforma e servomotori};
    
    % Power and voltage variation
\node[draw,
    below=of block1,
    minimum width=3.5cm,
    minimum height=1cm
] (block2) { Determina $h_0$ e $\alpha_0$};
    
% Voltage and Current Measurement
\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    below=of block2,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block3) { Riceve posizione $x,y,z,\varphi,\vartheta,\psi$};

\node[draw,
    below=of block3,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block4) {  Calcolo matrice rotazione $R_g$};

\node[draw,
    below=of block4,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=2.5cm, text centered
] (block5) { Calcolo distanza $l$};

\node[draw,
    below=of block5,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block6) { Calcolo $\alpha$ e il corrispettivo $w$};

\node[draw,
    diamond,
    right=of block6,
    minimum width=3.5cm,
    inner sep=2, aspect=2, xshift= 1.2cm] (block7) {Fuori range?};
    
\node[draw,
    right=of block7,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3.2cm, text centered, xshift=1.2cm
] (blocco) { Blocco sistema e accendo lampeggiate};

\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    above=of block7,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered, yshift= 0.75cm
] (block8) {Imposta $w$ ai servomotori};
 
% Conditions test
\node[draw,
    diamond,
    above=of block8,
    minimum width=3.5cm,
    inner sep=2, aspect=2, yshift= 0.75cm] (block9) { Nuova posizione?};
    
\node[draw,
    above right=of block9,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block10) { Mantieni posizione};
 

% Arrows
\draw[-latex] (block1) edge (block2)
			  (block2) edge (block3)
			  (block3) edge (block4)
			  (block4) edge (block5)
			  (block5) edge (block6)
   			  (block6) edge (block7)
   			  (block8) edge (block9);
   
\draw[-latex] (block7) -- (blocco) node[pos=0.2,fill=white,inner sep=2]{Sì};
 
\draw[-latex] (block7) -- (block8) node[pos=0.2,fill=white,inner sep=2]{No};

\draw[-latex] (block9) -- (block3) node[pos=0.2,fill=white,inner sep=2]{Sì};
 
\draw[-latex] (block9) |- (block10) node[pos=0.2,fill=white,inner sep=2]{No};
    
\draw[-latex] (block10) |- (block9);


\end{tikzpicture}
}
\caption{Schema logico piattaforma di Stewart.} \label{fig:ps}
\end{figure}

\newpage
\section{Controllo della pallina con piano stabilizzato}
\subsection{Controllore PID}\label{pid}
Il controllore PID è l'elemento chiave per il corretto funzionamento del sistema di stabilizzazione, esso riceve in ingresso la posizione della palla sul piano resistivo e si occupa di fornire opportuni parametri alla piattaforma di Stewart per fare in modo che sia raggiunto un determinato setpoint.
Questa azione di controllo è svolta tramite la combinazione lineare di tre contributi fondamentali, il proporzionale, l'integrale e il derivativo, da cui prende il nome. Questi effetti sono gestiti da tre variabili indipendenti $K_p$, $K_i$ e $K_d$ che ne pesano il contributo. 

\subsubsection{Equazione del controllore PID}

Segue un'analisi delle tre equazioni che permettono il controllo del sistema:

\begin{itemize}
\item Il controllore proporzionale ha equazione $u(t)=K_p \cdot e(t)$ e come si può facilmente notare ha lo scopo di rispondere in modo lineare allo scostamento della palla dalla posizione desiderata, lavora al presente.
\item Il controllore integrale ha equazione $u(t)=K_i \cdot \int_0^t e(\tau)d\tau$, il suo valore aumenta in relazione al tempo e alla distanza della pallina dal setpoint. Ha quindi lo scopo di annullare l'errore a riposo del sistema, lavora nel passato.
\item Il controllore derivativo ha equazione $u(t)=K_d\cdot \frac{de(t)}{dt}$, si oppone quindi alla variazione dell'errore ed è fondamentale per la stabilità del problema, lavora nel futuro.
\end{itemize}
Questi tre elementi sommati restituiscono l'equazione tempo continua seguente:

\begin{equation}\label{pidtc}
    u(t)=K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau)d\tau + K_d\cdot \frac{de(t)}{dt}
\end{equation}

Si può quindi procedere rappresentando complessivamente il sistema da controllare
e il relativo controllore, che risulta essere come in figura \ref{fig:PIDTC}, dove i segnali più importanti sono:
\begin{itemize}
\item x(t): il setpoint o obbiettivo da raggiungere, impostato manualmente.
\item u(t): il segnale d'uscita del sistema, ottenuto dal digitalizzatore resistivo.
\item e(t): l'errore, ottenuto dalla differenza tra il setpoint e il segnale in uscita.
\item c(t): variabile di controllo in uscita dal controllore PID che evolve opportunamente lo stato del sistema in modo da soddisfare le richieste del setpoint.

\end{itemize}

\begin{figure}[h!]
\centering
\scalebox{0.8}{
\begin{tikzpicture}[font=\small,thick]
 
% Start block
\node[draw,
    circle,
    minimum width=1cm,
     text centered] (block1) {$\Sigma$};
    
    % Power and voltage variation
\node[draw,
    right=of block1,
    minimum width=1cm,
    minimum height=1cm, xshift= 1cm
] (block2) {$K_i$};

\node[draw,
    right=of block2,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (int) {$\int_0^t$};



\node[draw, right=of int, 
    circle,
    minimum width=1cm,
     text centered] (S) {$\Sigma$};
    

\node[draw,
    right=of S,
    minimum width=2cm,
    minimum height=1cm,
    text width=2cm, text centered
] (block3) {Piattaforma Stewart};

\node[draw,
    right=of block3,
    minimum width=2cm,
    minimum height=1cm,
    text width=2cm, text centered
] (block4) {Piano resistivo};
 
\node[draw,
    above=of block2,
    minimum width=1cm,
    minimum height=1cm,yshift=-0.5cm
] (P) {$K_p$};

\node[draw,
    below=of block2,
    minimum width=1cm,
    minimum height=1cm,yshift=0.5cm
] (D) {$K_d$};

\node[draw,
    right=of D,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (der) {$\frac{d}{dt}$};


% Arrows
\draw [-latex] (-2cm,0cm) -- node[anchor=south]{$x(t)$}(block1)node[xshift=-0.75cm,yshift=-0.25cm]{$+$}node[xshift=0.25cm,yshift=-0.75cm]{$-$};
\draw [-latex] (block1) edge (block2)node[anchor=south, xshift=1cm]{$e(t)$};
\draw [-latex](1.5,0) |- (D);
\draw [-latex](1.5,0) |- (P);
\draw [-latex](D) edge (der);
\draw [-latex](block2) edge (int);
\draw [-latex](D) edge (der);
\draw [-latex](int) -- (S)node[anchor=south, xshift= 1cm]{$c(t)$};
\draw [-latex](P) -| (S)node[xshift=0.25cm,yshift=0.75cm]{$+$}node[xshift=-0.75cm,yshift=0.25cm]{$+$}node[xshift=-0.25cm,yshift=-0.75cm]{$+$};
\draw [-latex]	(der) -| (S);
\draw [-latex]	(S) edge (block3);	
\draw [-latex]	(block3) edge (block4);
\draw [-latex]	(block4) -- (16,0);	
\draw 	(15,0)node[anchor=south]{$u(t)$} -- (15,-3);		  
\draw [-latex]	(15,-3) -| (block1);	


\end{tikzpicture}
}
\caption{Schema logico controllore PID applicato al problema.} \label{fig:PIDTC}
\end{figure}


Lavorando con sistemi digitali tempo discreti non è però possibile impiegare la formula \eqref{pidtc}, sarà necessario procedere ad una discretizzazione, questa viene svolta in modo intuitivo applicando la nozione di differenze finite e considerando $\Delta t = t_k - t_{k-1}$ come periodo di campionamento. Il risultato è la seguente equazione:

\begin{equation}\label{pidtd}
    u(t_k)=K_p \cdot e(t_k) + K_i \cdot \sum_{i=1}^{t_k} e(t_i)\cdot \Delta t + K_d\cdot \frac{e(t_k)-e(t_{k-1})}{\Delta t}
\end{equation}



\subsection{Miglioramenti e ottimizzazioni del controllore PID}
Nonostante il PID sia di per sé un ottimo controllore teorico, nella realtà sono necessari degli accorgimenti per evitare comportamenti erronei che possono compromettere la stabilità e l'integrità del sistema. Segue una lista delle migliorie impiegate.
\begin{itemize}
\item Filtraggio del segnale: passo fondamentale per ottenere un sistema di controllo performante, dati rumorosi in ingresso rendono il sistema "nervoso" con scatti improvvisi che ne compromettono la stabilità.
\item Filtraggio dell'azione derivativa: la derivata, per sua natura, si comporta come un amplificatore di segnali in alta frequenza. Va quindi previsto un filtraggio che corregga questo effetto rendendo il segnale quanto più regolare.
\item Derivata sulla misura: consiste nell'eseguire la derivata sul segnle in uscita $u[k]$ invece che sull'errore $e[k]$, utile per evitare un brusco scatto al cambio del setpoint\footnote{Viene visto come uno spostamento molto veloce dalla componente derivativa.} e del tutto analoga alla derivata sull'errore con la sola differenza del segno invertito.
\item Anti-windup dell'integrale: il termine integrale può tendere a infinito nel caso l'errore non si annulli mantenendo sempre lo stesso segno, questo fenomeno è noto come windup e comporta il fallimento del sistema di controllo se prolungato per un tempo sufficientemente grande. Per evitare questo spiacevole effetto è utile limitare la somma del termine integrale in modo che questo si annulli rapidamente al cambio di segno dell'errore.
\item Limitazione dell'uscita: il controllore, non conoscendo i limiti fisici del progetto, può assegnare valori inammissibili al sistema da controllare, il che potrebbe anche risultare in una rottura. Si devono quindi stabilire dei limiti al range di valori assegnabili dal controllore.
\end{itemize}
\begin{figure}[h!]
\centering
\scalebox{0.65}{
\begin{tikzpicture}[font=\small,thick]
 
% Start block
\node[draw,
    circle,
    minimum width=1cm,
     text centered] (block1) {$\Sigma$};
    
    % Power and voltage variation
\node[draw,
    right=of block1,
    minimum width=1cm,
    minimum height=1cm, xshift= 1cm
] (block2) {$K_i$};

\node[draw,
    right=of block2,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (int) {$\Sigma_{t_k}$};

\node[draw, right=of int,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (filter4) {$\Lambda$};


\node[draw, right=of int, 
    circle,
    minimum width=1cm, xshift=2cm,
     text centered] (S) {$\Sigma$};
    
\node[draw, right=of S,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (filter3) {$\Lambda$};

\node[draw,
    right=of filter3,
    minimum width=2cm,
    minimum height=1cm,
    text width=2cm, text centered
] (block3) {Piattaforma Stewart};

\node[draw,
    right=of block3,
    minimum width=2cm,
    minimum height=1cm,
    text width=2cm, text centered
] (block4) {Piano resistivo};
 
\node[draw,
    above=of block2,
    minimum width=1cm,
    minimum height=1cm,yshift=-0.5cm
] (P) {$K_p$};

\node[draw,
    below=of block2,
    minimum width=1cm,
    minimum height=1cm,yshift=0.5cm
] (D) {$K_d$};

\node[draw,
    right=of D,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (der) {$\Delta_{t_k}$};

\node[draw,
    right=of der,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (filter1) {$\Phi$};

\node[draw,
    minimum width=1cm,
    minimum height=1cm,
     text centered, xshift=19cm, yshift=-1.5cm
] (filter2) {$\Phi$};



% Arrows
\draw [-latex] (-2cm,0cm) -- node[anchor=south]{$x[k]$}(block1)node[xshift=-0.75cm,yshift=-0.25cm]{$+$}node[xshift=0.25cm,yshift=-0.75cm]{$-$};
\draw [-latex] (block1) edge (block2)node[anchor=south, xshift=1cm]{$e[k]$};
\draw [-latex](1.5,-3) |- (D);
\draw [-latex](1.5,0) |- (P);
\draw [-latex](D) edge (der);
\draw [-latex](block2) edge (int);
\draw [-latex](D) edge (der);
%\draw [-latex](int) -- (S)node[anchor=south, xshift= 1cm]{$c[k]$};
\draw [-latex](P) -| (S)node[xshift=0.25cm,yshift=0.75cm]{$+$}node[xshift=-0.75cm,yshift=0.25cm]{$+$}node[xshift=-0.25cm,yshift=-0.75cm]{$+$};
\draw [-latex]	(filter1) -| (S);
\draw [-latex]	(filter4) -- (S);
\draw [-latex]	(int) -- (filter4);
\draw [-latex]	(der) -- (filter1);
\draw [-latex]	(S) edge (filter3);	
\draw [-latex]	(filter3) edge (block3);	
\draw [-latex]	(block3) edge (block4);
\draw [-latex]	(block4) -- (20,0);	
\draw 	(19,0)node[anchor=south]{$u[k]$} -- (filter2);
\draw (filter2) -- (19,-3);		  
\draw [-latex]	(19,-3) -| (block1);	
\end{tikzpicture}
}
\caption{Schema logico controllore PID migliorato.} \label{fig:pidmigliorato}
\end{figure}
Questi miglioramenti operativi sono mostrati in figura \ref{fig:pidmigliorato}, dove $\Sigma{t_k}$ indica l'integrale discretizzato e $\Delta{t_k}$ la derivata alle differenze finite. I filtri e i limitatori sono poi indicati rispettivamente con le lettere greche $\Phi$ e $\Lambda$.

\subsection{Algoritmo di controllo}
Vista la versatilità di applicazione del controllore PID, l'intero problema di controllo si traduce nella determinazione della posizione della pallina sul piano e lo svolgimento di opportune equazioni per ottenere i parametri richiesti come la velocità e l'accelerazione. Il comportamento del sistema di controllo si può quindi riassumere nello schema a blocchi di figura \ref{fig:stabilizzazione}, dove il blocco di assegnazione dei valori alla piattaforma richiama quello di figura \ref{fig:ps}.

\begin{figure}[h!]
\centering
\scalebox{0.9}{
\begin{tikzpicture}[font=\small,thick]
 
% Start block
\node[draw,
    rounded rectangle,
    minimum width=2.5cm,
    minimum height=1cm, text width=2cm, text centered] (start) {Accensione};
    
    
% Voltage and Current Measurement
\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    below=of block2,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered, below=of start
] (lettura) {Lettura posizione palla};

\node[draw,
    below=of lettura,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (calcolo) {  Calcolo velocità e accelerazione};

\node[draw,
    below=of calcolo,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=2.5cm, text centered
] (filtro) { Filtro limitando variazione};

\node[draw,
    below=of filtro,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (pid) { PID migliorato};

\node[draw,
    diamond,
    right=of pid,
    minimum width=3.5cm,
    inner sep=2, aspect=2, xshift= 1.2cm] (acc) {Valore accettabile?};
    
\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    below=of block2,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered, above=of acc, yshift= 0.5cm
] (piatt) {Assegna valore piattaforma};


\node[draw,
    right=of acc,
    minimum width=3cm,
    minimum height=1cm,
    text width=2.5cm, text centered, xshift= 1.2cm
] (max) { Usa valore massimo};
 

% Arrows
\draw 	[-latex](start) edge (lettura);		  
\draw [-latex]	(lettura) edge (calcolo);
\draw [-latex]	(calcolo) edge (filtro);	
\draw [-latex]	(filtro) edge (pid);
\draw [-latex]	(pid) edge (acc);
\draw [-latex]	(acc) edge (max)node[fill=white,inner sep=2,xshift = 2.5cm]{No};
\draw [-latex]	(max) |- (piatt);
\draw [-latex]	(acc) edge (piatt) node[fill=white,inner sep=2, yshift=1.5cm]{Sì};
\draw [-latex]	(piatt) |- (lettura);


\end{tikzpicture}
}
\caption{Schema logico sistema di stabilizzazione.} \label{fig:stabilizzazione}
\end{figure}
\newpage

\newpage


\section{Realizzazione pratica}
La realizzazione pratica del progetto è stata un processo discretamente complesso, svolto in modo sequenziale e analizzando costantemente le varie criticità. Questo si è svolto principalmente in 3 fasi: l'assemblaggio, la programmazione e la taratura del sistema, rispettivamente descritte in dettaglio nelle sezioni \ref{assemblaggio}, \ref{programmazione} e \ref{taratura}.

\subsection{Assemblaggio}\label{assemblaggio}
Sono state fornite la base con i servomotori, la piattaforma ed i relativi braccetti di collegamento, il piano resistivo e la scheda arduino UNO dotata di shield. I primi dubbi si sono verificati durante l'assemblaggio in quanto esistono quattro possibili varianti di piattaforma di Stewart con attuatori rotativi, rispettivamente con le manovelle interne o esterne e con i braccetti collegati alla piattaforma sullo stesso lato o su lati opposti. Analizzando la piattaforma si è preferito optare per una disposizione con manovelle esterne e braccetti su lati opposti. Si nota come queste configurazioni siano completamente equivalenti a livello matematico e necessitano unicamente di un ricalcolo della posizione dei punti di aggancio della piattaforma, il che mostra l'adattabilità del modello stesso. Alcuni dei pezzi necessari al completamento dell'assemblaggio, come gli agganci per la piattaforma e il piano resistivo, erano mancanti e dovevano essere realizzati. Disponendo di una stampante 3D si è optato per stampare i pezzi in modo da permettere una prototipazione rapida. Non disponendo dei file relativi alle dimensioni della base e della piattaforma, di compensato tagliato al laser, è stato fondamentale ricostruire fedelmente il modello in ambiene CAD per poi procedere alla modellazione delle parti mancanti (figura \ref{}). 

I modelli sono stati realizzati con il software Fusion360 e stampati in materiale plastico PLA con infill a nido d'ape per avere un buon compromesso tra leggerezza e rigidità. Ultimata la costruzione si è rivolta l'attenzione alle componenti elettroniche, innanzitutto è stato realizzato un connettore apposito per permettere un collegamento stabile tra i servomotori e la scheda Arduino, evitando inoltre possibili intralci al movimento della piattaforma. Notando la fragilità delle uscite del digitalizzatore, tramite un flat-cable flessibile, si è preferito realizzare un apposito aggacio che serva innanzitutto da strain-relief e faciliti la connessione dei cavi dupont per interfacciarsi con Arduino. Come precedentemente esposto nella sezione \ref{hbridge}, in seguito ad un analisi tramite multimetro della resistenza del digitalizzatore si è notato che un controllo diretto richiamerebbe solo $2V$, più che dimezzando la risoluzione del piano rispetto ai $5V$ nominali. La realizzazione pratica del driver per il piano resistivo richiede l'impiego di un montaggio apposito su basetta di vetronite per ridurre al minimo le capacità parassite e i falsi contatti rispetto ad una basetta sperimentale. Non essendo certi dell'influenza dello shoot-through\footnote{Conduzione simultanea di entrambi i mosfet su un ramo durante la commutazione.} dei MOSFET è stata prevista una resistenza di $1\Omega$ verso massa, in modo da limitare l'eventuale corrente massima a $5A$, entro il range previsto dal datasheet di $4A$ continui e $27A$ pulsati. Un altra caratteristica è la presenza delle resistenze di Gate, queste sono state previste nel caso in cui si dovesse eseguire un ulteriore pilotaggio tramite componente attivo per evitare lo shoot-through ma in seguito alla prova pratica questo non è stato necessario. É seguita un analisi dei tempi con l'oscilloscopio, importantissima nella successiva parte di programmazione, con la quale si è determinato il periodo minimo di campionamento che risulta essere di soli $50\mu s$. Infine è stato implementato senza particolari accorgimenti il joystick in quanto è bastato collegare i cavi direttamente allo shield per avere delle ottime letture.

\subsection{Programmazione}\label{programmazione}
La programmazione è senza dubbio la parte principale del progetto e per sa sua versatilità ricopre un ruolo fondamentale. Vista la complessità del sistema, lo sviluppo del software è stato diviso in diversi blocchi operativi, ognuno dei quali svolge un ruolo diverso e indipendente dagli altri, che saranno trattati nelle successive sezioni.
%\begin{itemize}
%\item Il controllo della piattaforma di Stewart.
%\item La lettura e il filtraggio dei dati in ingresso dal piano resistivo.
%\item L'elaborazione del segnale in ingresso da parte del PID.
%\item La gestione dei comandi assegnati tramite joystick.
%\end{itemize}
%Segue un analisi di queste procedure.
\subsubsection{Controllo della piattaforma di Stewart}
Il controllo della piattaforma di Stewart è stato trattato in modo estensivo dal punto di vista matematico nella sezione \ref{pianostewart}, la programmazione in questo caso si occupa quindi di riproporre fedelmente queste equazioni in linguaggio \texttt{C}, con alcuni accorgimenti specifici relativi all'implementazione del software stesso. Come struttura dati, visto il numero elevato di variabli, si è scelto di impiegare le matrici, vista anche la facilità di implementazione di algoritmi per eseguire le varie operazioni richieste. Una nota particolare va fatta in merito all'algoritmo di controllo delle posizioni irraggiungibili presente nel seguente listato.
\begin{lstlisting}[language=C]
int emergenza = 0;
  for(int i = 0; i < 6; i++){
    if(constrain(getAmpImp(alfa[i],i),inf,sup) == sup ||
       constrain(getAmpImp(alfa[i],i),inf,sup) == inf ||
       isnan(constrain(getAmpImp(alfa[i],i),inf,sup))){     
      emergenza++;
    }
  }
  if(emergenza == 0){
    for(int i = 0; i < 6; i++){
        servo[i].writeMicroseconds(constrain(getAmpImp(alfa[i],i),inf,sup));
    }
  }
  else{
    Serial.println("Limite raggiunto, arresto motori.");
    fermoEmergenza();
  }
\end{lstlisting}
Ogni computazione della posizione richiesta comporta la generazione di sei valori che saranno poi assegnati come angoli ai servomotori. Prima che questo avvenga, un ciclo \texttt{for} si occupa di controllare tutti i valori generati per verificare che questi siano compresi in un limite inferiore o superiore, ma soprattutto verifica che il valore sia effettivamente computabile. Nella formula \eqref{alfa}, nel caso si assegni un valore impossibile la funzione $arcsin$ diventa indefinita, espressa in \texttt{C} con il simbolo \texttt{NaN}, è per questo fondamentale l'impiego della funzione \texttt{isnan} per verificare se questo è il caso. Se una delle tre condizioni non è rispettata il contatore \texttt{emergenza} viene incrementato, utile per capire quanti servomotori abbiano ricevuto un valore errato. A questo punto, se non si sono verificati disguidi, si può procedere con l'assegnazione dei valori impiegando \texttt{writeMicroseconds}, che assegna l'angolo ai sevomotori dopo che è stato opportunamente convertito in microsecondi dalla funzione \texttt{getAmpImp}.
Se uno degli angoli non rispetta i vincoli l'assegnazione viene saltata e si passa direttamente alla routine di blocco \texttt{fermoEmergenza} che blocca il sistema e accende un LED lampeggiante di segnalazione.

\subsubsection{Lettura e filtraggio dati ottenuti dal piano resistivo}
La lettura dei segnali provenienti dal piano resistivo è svolta leggendo sequenzialmente lo stato dei pin analogici di Arduino con la seguente funzione.
\begin{lstlisting}[language=C]
void getSense(){
  digitalWrite(in1,HIGH);
  digitalWrite(in2,LOW);
  delayMicroseconds(on);
  x = (analogRead(sensePin)-100)*(0.34/820);

  digitalWrite(in1,LOW);
  digitalWrite(in2,HIGH);
  delayMicroseconds(on);
  y = (analogRead(sensePin)-100)*(0.27/820);
  lastsense = micros();
}
\end{lstlisting}
Questa prevede la creazione di un gradiente lungo l'asse $x$, per la durata espressa dalla variabile \texttt{on} che permette la stabilizzazione del segnale, la cui durata è ricavata sperimentalmente osservando il tempo di salita all'oscilloscopio come riportato in figura \ref{fig:temposalita}. 
\begin{figure}[h!]
\centering
\scalebox{0.5}{
\includegraphics{segnale.png}
}
\caption{Misura del tempo di salita del segnale.} \label{fig:temposalita}
\end{figure}
In seguito alla stabilizzazione si procede con campionamento. Lo stesso si ripete in modo del tutto analogo per l'asse $y$. Viene inoltre effettuata una semplice conversione della posizione da step a metri prima di assegnarlo alla variabile. L'elemento chiave per un buon funzionamento del controllore è l'impiego di dati liberi da rumore e impulsi esterni, i dati provenienti dal piano resistivo però si sono subito mostrati non ideali, presentando un rumore impulsivo estremamente elevato, di ampiezza pari al 50\% della massima escursione del segnale utile. Questi impulsi sono principalmente dovuti alla presenza di una lieve zigrinatura sul digitalizzatore resistivo, probabilmente dovuta ai distanziatori tra i due strati conduttivi, che dà alla pallina un moto non del tutto uniforme ma con dei piccoli sobbalzi che ne fanno perdere il contatto. Per evitare questo effetto si è provato a sovrapporre al piano uno strato di materiale liscio, che colmasse le asperità, ma questo si è rivelato di scarso successo. Visto l'obbiligo di inserire un filtraggio si è preferito un implementazione software rispetto a hardware per una maggiore flessibilità. Il filtraggio scelto non può comportare un ritardo nel tempo di risposta, si è quindi optato per un filtro che lavora in modo diretto limitando la derivata della variabile da filtrare. Nel seguente listato viene svolto il filtraggio della posizione della pallina nel piano.

\begin{lstlisting}[language=C]
xVel = (x - xOld)/deltaTime;
yVel = (y - yOld)/deltaTime;

float maxVel = 0.4;
if(abs(xVel) > maxVel){
  if(xVel > 0){
    x = xOld + maxVel*(deltaTime);
  }
  else{
    x = xOld - maxVel*(deltaTime);
  }
}
if(abs(yVel) > maxVel){
  if(yVel > 0){
    y = yOld + maxVel*(deltaTime);
  }
  else{
    y = yOld - maxVel*(deltaTime);
  }
}
\end{lstlisting}
In questo caso la derivata della posizione è la velocità, calcolata rispetto alla posizione precedente e al tempo di ciclo. Si è quindi imposta una velocità massima, che limita la pendenza del grafico della posizione, eliminando così in modo efficace gli impulsi più sostanziali come visibile in figura \ref{fig:filtraggioposizione}, dove la linea verde indica il segnale originale e la rossa dopo il filtraggio.
\begin{figure}[h!]
\centering
\scalebox{0.2}{
\includegraphics{filtraggio.png}
}
\caption{Confronto diretto tra segnale in ingresso e filtrato.} \label{fig:filtraggioposizione}
\end{figure}
Si nota poi come svolgendo la derivata del segnale filtrato, questa tenderà ad amplificare il piccolo rumore residuo, si è quindi deciso di ripetere un operazione di filtraggio analoga per la velocità limitando questa volta l'accelerazione massima.

\subsubsection{Controllore PID}
\subsubsection{Assegnazione dei comandi}
L'assegnazione dei comandi è svolta tramite l'ausilio di un joystick analogico, la presenza di uno switch interno ha inoltre permesso di disporre i comandi su diversi livelli. Nel livello base sono programmate delle analisi statiche, ovvero con un setpoint fisso, il joystick centrato imposta il setpoint al centro del piano, le altre 4 direzioni (joystick in alto, basso, sinistra, destra) hanno lo scopo di spostare il setpoint nella rispettiva direzione di $6cm$. Questi setpoint sono ottimi per valutare la risposta al gradino del sistema che sarà poi fondamentale nella sezione relativa alla taratura. Il secondo livello, raggiungibile premendo l'interruttore, offre la possibilità di eseguire delle analisi dinamiche, in queste il setpoint è in costante movimento e sono utili per mostrare la responsività e la precisione del sistema. Queste analisi dinamiche si incentrano sulla realizzazione di figure di vario tipo da parte della pallina, i due esempi realizzati sono un cerchio e il simbolo di infinito. Il simbolo di infito in particolare è un ottimo circuito di prova per testare la qualità del controllo in quanto prevede tratti ad alta e bassa velocità in rettilineo e in curva.

\subsection{Taratura}\label{taratura}

\section{Risultati}
\subsection{Piattaforma di stewart}
\subsection{Piano stabilizzato}
\section{Conclusioni}

\begin{figure}[h!]
\centering
\scalebox{0.8}{
\includegraphics{circle.png}
}
\caption{Tracking del setpoint su una curva circolare.} \label{fig:cerchio}
\end{figure}
\begin{figure}[h!]
\centering
\scalebox{0.8}{
\includegraphics{infinity.png}
}
\caption{Tracking del setpoint su una curva a forma di infinito.} \label{fig:cerchio}
\end{figure}

%AGGIUNGERE BIBLIOGRAFIA
%\bibliographystyle{alpha}
%\bibliography{references} % see references.bib for bibliography management
\addcontentsline{toc}{chapter}{\refname}
%\nocite{*}
\printbibliography
\end{document}


