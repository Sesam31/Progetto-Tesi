\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage[a4paper]{geometry}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{hyperref}
\usepackage[italian]{babel}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows.meta, positioning}

\oddsidemargin 0pt
\evensidemargin 0pt
\marginparwidth 40pt
\marginparsep 10pt
\topmargin -20pt
\headsep 10pt
\textheight 8.7in
\textwidth 6.65in
\linespread{1.2}

\title{Stabilizzazione nel piano di Gough-Stewart}
\author{Daniele Facco}
\date{}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\rr}{\mathbb{R}}

\newcommand{\al}{\alpha}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\aff}{aff}

\begin{document}

\maketitle
\tableofcontents
\newpage

%\begin{abstract}
%Studio della piattaforma di Stewart e dei suoi componenti.
%\end{abstract}

\section{Introduzione}\label{intro}


\section{Tecnologie impiegate}\label{tecnologie}

\subsection{Piattaforma Arduino}\label{arduino}
L'intero progetto si basa su una unità di controllo centrale, è quindi fondamentale implementare un processore con discrete capacità elaborative. Una scelta molto comune è quella di impiegare schede Arduino che, con il vantaggio di essere OpenHardware hanno raggiunto una discreta ubiquità nel settore, anche grazie ad un ambiente di sviluppo completo e ad un sistema di librerie molto supportato dai produttori di componenti. La scheda impiegata è un Arduino UNO con un processore ATmega328P che permette di avere una frequenza di clock di $16MHz$, perfettamente in grado di gestire la rapidità di calcolo richiesta dal progetto. Alla scheda impiegata è stato poi montato uno "shield", un componente che rimappa i pin in modo più conveniente per connettere dispositivi quali servomotori, display LCD, moduli bluetooth e altri oltre che facilitare l'alimentazione esterna tramite appositi morsetti. Nella realizzazione sono stati impiegati diversi pin, tra i quali tutti i pin con capacità PWM per il controllo dei servomotori, rispettivamente in posizione 3, 5, 6, 9, 10, 11 e pin 12, 13 e A0 per il controllo del piano resistivo.

\subsection{Servomotori}\label{servomotori}
I servomotori sono l'elemento principale nella realizzazione della piattaforma di Stewart. Questi attuatori sono controllati in modalità PWM dalla scheda Arduino tramite la libreria \emph{Servo.h}. L'interpretazione del segnale in ingresso è gestita da un apposito chip di controllo che lo trasforma e lo invia a un motore DC brushless, che tramite un apposito gearbox ad alta riduzione fa ruotare l'asse. La rotazione dell'asse è inoltre recepita dal controllore interno tramite un potenziometro, dando quindi la possibilità di aumentare la coppia se il setpoint non è raggiunto. L'intero sistema è riassunto in figura \ref{fig:servo}. 
\begin{figure}[h!]
\centering
\scalebox{1}{
\begin{tikzpicture}[font=\small,thick]

\filldraw  [fill=blue!50](0cm,0cm) rectangle (4cm,3cm);
\filldraw [fill=white](0.25cm,0.25cm) rectangle (1.5cm,2.25cm)node[xshift=-0.625cm, yshift=-1cm]{DC};
\filldraw [fill=black] (2.5cm,2cm) rectangle (3cm,3.5cm);
\filldraw  [fill=white](0.25cm,2.25cm) rectangle (3.75cm,2.75cm)node[xshift=-1.75cm, yshift=-0.25cm]{Gearbox};
\filldraw [fill=white] (2.25cm,2cm) rectangle (3.25cm,1.5cm)node[xshift=-0.5cm, yshift=0.25cm]{Pot.};
\filldraw [fill=white] (2cm,0.25cm) rectangle (3.5cm,1.25cm)node[xshift=-0.75cm, yshift=-0.5cm]{Chip};
\draw [line width=2pt](2,0.5) -- (1.5,0.5);
\draw [line width=2pt](2,1) -- (1.5,1);
\draw [line width=2pt](2.5,1.25) -- (2.5,1.5);
\draw [line width=2pt](2.75,1.25) -- (2.75,1.5);
\draw [line width=2pt](3,1.25) -- (3,1.5);
\draw [line width=2pt](3.5,0.5) -- (7,0.5)node[anchor= south]{GND};
\draw [line width=2pt](3.5,0.75) -- (6,0.75)node[anchor= south]{5V};
\draw [line width=2pt](3.5,1) -- (5,1)node[anchor= south]{Segnale};

\end{tikzpicture}
}
\caption{Componenti del servomotore.} \label{fig:servo}
\end{figure}
A causa del loro elevato rapporto di riduzione questi componenti possono produrre una coppia elevata\footnote{I servomotori impiegati possono sollevare una massa di $3,5kg$ con una manovella di lunghezza nominale $1cm$.}, questo aspetto  non va sottovalutato ed è sempre necessario gestire l'evenienza di uno sforzo durante l'operazione della piattaforma.
Il segnale inviato ai servomotori è periodico, di periodo $20ms$ e presenta uno stato on/off a livello logico per un tempo prefissato a seconda della posizione richiesta. In figura \ref{fig:servocontrol} è descritto il segnale PWM al variare dell'angolo richiesto. 
\begin{figure}[h!]
\centering
\scalebox{1}{
\begin{tikzpicture}[font=\small,thick]
 

\draw [-latex] (0cm,0cm) -- (0cm,1.5cm);
\draw [-latex] (0cm,0cm) -- (5.5cm,0cm)node[anchor= west]{$t$};

\draw [-latex] (0cm,-2cm) -- (0cm,-0.5cm);
\draw [-latex] (0cm,-2cm) -- (5.5cm,-2cm)node[anchor= west]{$t$};

\draw [-latex] (0cm,-4cm) -- (0cm,-2.5cm);
\draw [-latex] (0cm,-4cm) -- (5.5cm,-4cm)node[anchor= west]{$t$};

\draw (0cm,1cm) -- (0.25cm,1cm);
\draw (0cm,-1cm) -- (0.375cm,-1cm);
\draw (0cm,-3cm) -- (0.5cm,-3cm);

\draw (0.25cm,0cm) -- (0.25cm,1cm)node[anchor= west]{$1ms$};
\draw (0.375cm,-2cm) -- (0.375cm,-1cm)node[anchor= west]{$1,5ms$};
\draw (0.5cm,-4cm) -- (0.5cm,-3cm)node[anchor= west]{$2ms$};

\draw (5cm,0.05cm)node[anchor= north]{$20ms$} -- (5cm,-0.05cm);
\draw (5cm,-2.05cm)node[anchor= north]{$20ms$} -- (5cm,-1.95cm);
\draw (5cm,-4.05cm)node[anchor= north]{$20ms$} -- (5cm,-3.95cm);

\filldraw [fill=black] (7,0.75) circle (3pt) node[xshift= -0.75cm] {$0^\circ$};
\filldraw [fill=black] (7,-1.25) circle (3pt) node[xshift= -0.75cm] {$90^\circ$};
\filldraw [fill=black] (7,-3.25) circle (3pt) node[xshift= -0.75cm] {$180^\circ$};

\draw [line width=1mm](7,0.75) -- (7cm,1.75cm);
\draw  [line width=1mm](7,-1.25) -- (8cm,-1.25cm);
\draw [line width=1mm](7,-3.25) -- (7cm,-4.25cm);

\end{tikzpicture}
}
\caption{Angolo servomotore al variare del PWM.} \label{fig:servocontrol}
\end{figure}
Il controllo di questi elementi è svolto dal processore tramite uno shield che ne facilita l'installazione. Una nota particolare va fatta in merito alla potenza richiesta dai servomotori, nonostante il loro consumo in stato "idle" sia di circa $10mW$, durante il movimento questo può raggiungere oltre $300mW$. É quindi necessaria una alimentazione esterna che sia in grado di fornire almeno $2A$ a $5V$ in quanto la scheda alimentata, tramite usb dalla presa del computer, può ricevere al massimo $1A$. Una nota particolare va fatta in merito alla scelta di impiegare servomotori rispetto agli stepper, mentre il primo presentano un posizionamento assoluto, determinato dal segnale PWM e un feedback continuo sulla posizione, il secondo si basa su un posizionamento relativo, sarebbe quindi necessaria un'azione di calibrazione ad ogni accensione del dispositivo, che vogliamo evitare.

\subsection{Piano resistivo}\label{pianoresistivo}
Per attuare correttamente la stabilizzazione del piano è fondamentale l'impiego di un sistema resistente ai disturbi che sia in grado determinare, con la massima precisione possibile, la posizione della sfera da bilanciare. Questo può essere svolto impiegando diverse tecniche come matrici di laser, rilevazione video o per l'appunto tramite l'uso di un piano resistivo.
É stato scelto di impiegare un digitalizzatore resistivo per il tracking della pallina in quanto è meno soggetto a disturbi ambientali, in particolare da effetti ottici, rispetto alla matrice laser e alla rilevazione video.
Il tracking video avrebbe inoltre richiesto un notevole incremento della complessità del sistema, necessitando di un SOC completo e di software dedicato come OpenCV.
\subsubsection{Tipologie e funzionamento di un piano resistivo}\label{tipofunz}
I piani resistivi sono generalmente caratterizzati dal numero di cavi in uscita, questo può essere generalmente quattro, cinque o otto. La versione a otto fili è una semplice evoluzione della variante a quattro e non sarà trattata in dettaglio. Questi dispositivi sono costituiti da due strati, di vetro o plastica, ricoperti da un sottile strato di ossido di indio-stagno\footnote{Materiale scelto appositamente per le ottime proprietà di trasparenza e conduzione.} e separati da minuscoli spaziatori, rappresentato in figura \ref{fig:sezione}. 
\begin{figure}[h!]
\centering
\scalebox{0.75}{
\begin{tikzpicture}[font=\small,thick]
 

\filldraw [fill=cyan!50](0cm,0cm) rectangle (0.5cm,5cm);
\draw (0.5cm,0cm) rectangle (0.7cm,5cm);

\draw (1.5cm,0cm) rectangle (1.75cm,5cm);
\filldraw [fill=cyan!50] (1.75cm,0cm) rectangle (2.25cm,5cm);
\filldraw [fill=black!50](1.5,4.5) arc (90:270:0.75cm);
\filldraw [fill=black!50](1.5,2cm) arc (90:270:0.75cm);
\end{tikzpicture}
}
\caption{Sezione del digitalizzatore resistivo.} \label{fig:sezione}
\end{figure}
La resistenza del conduttore è uniforme su tutta la superficie e alla pressione si forma un contatto tra i due strati che permette un passaggio di corrente.
Nella versione a quattro fili su entrambi i piani si forma un gradiente di potenziale nelle direzioni rispettivamente \emph{x} e \emph{y} e ognuno dei due misura il potenziale dell'altro. Nella versione a cinque invece si ha un piano su cui viene alternata la direzione del gradiente mentre l'altro effettua la misura.
Nella realizzazione del progetto è stata impiegata la variante a cinque fili.
\begin{figure}[h!]
\centering
\scalebox{0.25}{
\includegraphics{5wire.png}
}
\caption{Schematica circuitale piano resistivo a cinque fili.} \label{fig:controllo}
\end{figure}

\subsection{Ponte ad H}\label{hbridge}

É emersa la necessità di impiegare un ponte ad H in seguito ad una analisi preliminare delle specifiche del digitalizzatore resistivo. Si è infatti notato in seguito a una misura di resistenza, che questa fosse di soli $100 \Omega$, quindi non compatibile con le periferiche dell'Arduino UNO, in quanto, a $5V$ richiama una corrente di $50mA$ mentre la scheda ne supporta solo $20$. L'impiego del ponte ad H evita questo richiamo di corrente eccessivo impiegando dispositivi come BJT o MOSFET ed una sorgente esterna per controllare il piano. Nella scelta della tecnologia da impiegare sono stati scelti i MOSFET in quanto meno sensibili a fattori ambientali e più adatti alla commutazione di segnali digitali rispetto ai BJT. Non disponendo del componente finito si è scelto di realizzarlo a partire dai singoli componenti in seguito ad un'analisi accurata tramite software SPICE (figura \ref{fig:controllo}) e basandosi sul datasheet del chip L298N.
\begin{figure}[h!]
\centering
\scalebox{0.25}{
\includegraphics{CircuitoControlloNo.png}
}
\caption{Schematica circuito di controllo.} \label{fig:controllo}
\end{figure}
I MOSFET scelti sono degli AO3400 e A03401, rispettivamente nella configurazione n e p in quanto forniscono ottime prestazioni. Da un'analisi del sistema di controllo richiesto dal piano resistivo si è deciso di rinunciare alla capacità di gestire individualmente i singoli MOSFET favorendo due linee di controllo che possano commutare tra gli stati High/Low. Sono state inoltre impiegate delle porte logiche NAND con lo scopo di migliorare il segnale di ingresso proveniente da Arduino ed evitare eventuali problemi di ritardo di commutazione, questa pratica è comune anche nel caso del L298N. Come chip per le porte NAND si è scelto un TC4011BP, questo fornisce in un singolo package quattro porte logiche che sono state configurate come invertenti in cascata, principalmente per una questione di convenienza, nel caso in cui sia necessario impiegare il segnale negato.


\newpage

\section{Piattaforma di Stewart}\label{pianostewart}



\subsection{Descrizione}\label{piattaformastewart}
La piattaforma di Stewart è un particolare sistema meccanico, costituito da una base su cui sono posizionati sei attuatori di vario tipo collegati alla piattaforma superiore mediante giunti snodabili. Un esempio comune sono gli attuatori prismatici: pistoni lineari che presentano un solo grado di libertà. Nel progetto vengono impiegati servomotori che presentano il vantaggio di essere certamente più economici rispetto agli attuatori prismatici ma il sistema risultante assume un grado di complessità superiore. Tramite opportune osservazioni matematiche è possibile risalire a un modello equivalente a quello degli attuatori prismatici che garantisce un range di movimento ottimale.

\subsection{Robot seriali e paralleli}\label{robotserialiparalleli}
È utile enunciare la differenza tra robot di tipo seriale e parallelo per comprendere le successive implicazioni a livello matematico.
I robot seriali prevedono una serie di giunti snodabili controllati da attuatori, che spesso assumono le caratteristiche di un arto antropomorfo. 
Questi tipi di robot prendono spesso il nome di braccio meccanico e trovano ampia applicazione nell'industria meccanica.
Nei robot paralleli invece, gli attuatori agiscono tutti sullo stesso elemento tramite giunti indipendenti. 
La piattaforma di Stewart ne è il principale esempio e trova applicazione soprattutto nella realizzazione di simulatori avanzati di volo o per testare veicoli nelle case automobilistiche.\footnote{Si nota come i delta-robot siano sostanzialmente delle versioni "limitate" della piattaforma di Stewart a soli 3 gradi di libertà.}
Entrambi i sistemi presentano 6 gradi di libertà, indicati anche come $6DOF$, ma il problema matematico che li caratterizza è fondamentalmente opposto.


\begin{figure}[h!]
\centering
\scalebox{1}{
\begin{tikzpicture}[font=\small,thick]
 
\node[draw,
    minimum width=2cm,
    minimum height=1cm,
    text width=2cm, text centered
] (block1) {Sistema};

\draw [-latex] (-2cm,0cm)node[anchor=east]{$(\vartheta_1,\vartheta_2,...,\vartheta_n)$} -- (block1);
\draw [-latex] (block1) -- (2cm,0cm)node[anchor=west]{$(x,y,z,\varphi,\vartheta,\psi)$};
\draw node[yshift=-2cm,xshift=-3.5cm]{$(x,y,z,\varphi,\vartheta,\psi)=S(\vartheta_1,\vartheta_2,...,\vartheta_n)$};
\draw node[yshift=-1.25cm,xshift=0cm]{Problemi:};
\draw node[yshift=-2.5cm,xshift=-3.5cm]{Diretto};
\draw node[yshift=-2cm,xshift=3.5cm]{$(\vartheta_1,\vartheta_2,...,\vartheta_n)=S(x,y,z,\varphi,\vartheta,\psi)$};
\draw node[yshift=-2.5cm,xshift=3.5cm]{Inverso};

\end{tikzpicture}
}
\caption{Problemi diretti e inversi.} \label{fig:direttoinverso}
\end{figure}

Se nei robot seriali, noto l'orientamento degli attuatori, è facile risalire alla posizione dell'end effector; lo stesso non si può dire del problema inverso. Nota la posizione dell'end effector è infatti estremamente difficile risalire all'orientamento degli attuatori che permette raggiungere quella determinata locazione. Il problema di Stewart è esattamente l'opposto, è molto difficile ottenere equazioni che ci permettano di descrivere le coordinate e la rotazione del piano al variare dell'angolo dell'attuatore rotativo\footnote{Prevede la risoluzione di un sistema di 18 equazioni differenziali non lineari con 40 possibili soluzioni.}, è invece molto facile risalire all'angolo dei servomotori a partire dalla posizione nota del piano nello spazio impiegando semplici nozioni di trigonometria. Queste nozioni di cinematica sono riassunte nella tabella \ref{fig:tabella}.

\begin{table}[h!]
\centering
\begin{tabular}{c|cc}
        & Seriale   & Parallelo  \\ 
\hline
Diretto & Facile    & Difficile  \\
Inverso & Difficile & Facile    
\end{tabular}
\caption{Difficoltà problemi diretti e inversi} \label{fig:tabella}
\end{table}



Nello svolgimento successivo si è preferito risalire alle equazioni della cinematica inversa della piattaforma di Stewart in quanto le dirette non sono necessarie ai fini dello svolgimento e richiederebbero inoltre un carico eccessivo da parte del microprocessore.



\subsection{Analisi piattaforma di Stewart con attuatori rotativi}\label{analisi}

Il problema della piattaforma di Stewart controllata da attuatori rotativi è fondamentalmente costituito da due sotto-problemi.
Il primo relativo alla determinazione delle lunghezze dei vettori che collegano la base alla piattaforma per ogni possibile posizione, trattato nella sezione \ref{platform}. Il secondo tratta invece dell'implementazione stessa dei servomotori, per via della complessità di descrizione del sistema biella manovella impiegato, trattato nella sezione \ref{rotation}. 

\subsection{Analisi problema piattaforma}\label{platform}

Si definiscono due sistemi di riferimento cartesiani che caratterizzano il sistema, mostrati nella figura \ref{fig:sistema}, uno fisso per la base centrato in $O$ di versori $\hat{i},\hat{j},\hat{k}$ e uno variabile per la piattaforma centrato in $O'$ di versori $\hat{i'},\hat{j'},\hat{k'}$. Sono note le coordinate in tre dimensioni dei punti degli assi di rotazione dei servomotori $({B_i})$ e dei giunti della piattaforma $(P_i)$, quando questa è in posizione orizzontale a riposo rispetto al sistema di riferimento centrato nella base. Il problema consiste nel definire la posizione dei giunti della piattaforma nello spazio al variare di un set di valori $(x,y,z,\varphi,\vartheta,\psi)$ rispetto al riferimento fisso della base. I valori $(x,y,z,\varphi,\vartheta,\psi)$ precedentemente enunciati, si riferiscono alla posizione e rotazione nello spazio della piattaforma rispetto alla base; $(x,y,z)$ sono i valori del centro della piattaforma mentre $(\varphi,\vartheta,\psi)$ sono le rotazioni, rispettivamente roll, pitch e yaw (rollio, beccheggio e imbardata). Nell'analisi, si considerano separatamente gli effetti traslativi e rotativi.

\begin{figure}[h!]
\centering

\scalebox{0.75}{
\begin{tikzpicture}

\filldraw[fill=yellow!50,rotate around={-10:(0,7cm)},xshift=2cm,yshift=1cm] (0,7cm) ellipse (4cm and 2cm);
\filldraw [fill=red!50](0,0) ellipse (5cm and 2.5cm);
\draw [-latex, thick] (0,0) -- node[anchor=south]{$\hat b_i$}(5cm,0);
\draw [-latex, thick] (0,0) -- node[anchor=east]{$\hat T$}(2.15cm,7.65cm);
\draw [-latex, thick] (0,0) -- node[anchor=north]{$\hat q_i$}(6.1cm,6.95cm);
\draw [-latex, thick] (5cm,0) -- node[anchor=west]{$\hat l_i$}(6.1cm,6.95cm);
\draw[-latex, thick,rotate around={-10:(0,7cm)},xshift=2cm,yshift=1cm] (0cm,7cm) -- node[anchor=south]{$\hat p_i$}(4cm,7cm);
\filldraw [fill=black] (0,0) circle (2pt) node[yshift= -0.25cm] {$O$} node[xshift= -2cm] {Base};
\filldraw [fill=black] (5cm,0) circle (2pt) node[anchor=west]{$B_i$};
\filldraw [fill=black] (2.15cm,7.65cm) circle (2pt) node[yshift= 0.25cm] {$O'$} node[xshift= -2cm] {Piattaforma};
\filldraw [fill=black] (6.1cm,6.95cm) circle (2pt) node[anchor=west]{$P_i$};
\draw [-latex, thick] (-1,-1.5) -- node[anchor=north]{$\hat i$}(0cm,-1.5cm);
\draw [-latex, thick] (-1,-1.5) -- node[anchor=east]{$\hat k$}(-1cm,-0.5cm);
\draw [-latex, thick,rotate around={-120:(-1,-1.5cm)}] (-1,-1.5) -- node[anchor=east]{$\hat j$}(-0.5cm,-1.5cm);

\draw [-latex, thick,rotate around={-10:(0,8.5cm)}] (0,8.5) -- node[anchor=north]{$\hat {i'}$}(1cm,8.5cm);
\draw [-latex, thick,rotate around={-10:(0,8.5cm)}] (0,8.5) -- node[anchor=east]{$\hat {k'}$}(0cm,9.5cm);
\draw [-latex, thick,rotate around={-130:(0,8.5cm)}] (0,8.5) -- node[anchor=east]{$\hat {j'}$}(0.5cm,8.5cm);

\end{tikzpicture}
}
\caption{Sistemi di rifermento e vettori nel piano di Stewart.} \label{fig:sistema}
\end{figure}

\newpage
\subsubsection{Analisi traslazione \boldmath$(x,y,z)$}\label{xyz}
Le variazioni in $(x,y,z)$ comportano una semplice traslazione dei punti del piano, questa viene indicata con un vettore $\hat T$ che andrà poi a sommarsi alla variazione dovuta a $(\varphi,\vartheta,\psi)$.

\subsubsection{Analisi rotazione \boldmath$(\varphi,\vartheta,\psi)$}\label{ftp}
Per semplificare l'analisi si considerano, separatamente, gli effetti dovuti a queste tre componenti. Si studia il caso di solo rollio $(\varphi,0,0)$ per risalire alle coordinate di un punto $P:(x,y,z)$ rispetto alla base in seguito a una rotazione di $\varphi$ gradi che lo ha traslato nel punto $(x',y',z')$. Per fare ciò, è necessario ottenere un'applicazione lineare che permetta di passare dal sistema di coordinate della piattaforma al sistema di coordinate della base.

\begin{figure}[h!]
\centering
\scalebox{0.8}{
\begin{tikzpicture}
\draw [-latex](0,0) -- (4cm,0)node[anchor=north]{$\hat{j}$};
\draw [-latex](0,0) -- (0,4cm)node[anchor=east]{$\hat{k}$};

\draw [-latex,rotate around={30:(0,0cm)}](0,0) -- (4cm,0)node[anchor=south]{$\hat{j'}$};
\draw [-latex,rotate around={30:(0,0cm)}](0,0) -- (0,4cm)node[anchor=east]{$\hat{k'}$};

\draw [rotate around={60:(0,0cm)}](0,0) -- (3cm,0)node[anchor=south]{$\hat{P}$};

\draw (0,0)node[xshift= 1.25cm,yshift= 0.25cm]{$\varphi$} -- (10mm,0mm) arc  (0:30:10mm)-- cycle;
\filldraw [-latex,fill=black] (0cm,0cm) circle (2pt) node[xshift=-0.25cm,yshift=-0.25cm]{$\hat{i}$};
\filldraw [-latex,fill=black] (1.5cm,2.6cm) circle (2pt);
\draw [dashed,rotate around={30:(0,0cm)}](2.6cm,0cm) -- (2.6cm,1.5cm);
\draw [dashed,rotate around={30:(0,0cm)}](0cm,1.5cm) -- (2.6cm,1.5cm);

\draw (1.5cm,2.6cm)node[xshift= 0.5cm,yshift= -0.3cm]{$\varphi$} -- (1.5cm,2.1cm) arc  (270: 300:5mm)-- cycle;

\draw [dashed](1.5cm,0cm) -- (1.5cm,2.6cm);
\draw [dashed](0cm,2.6cm) -- (1.5cm,2.6cm);

\end{tikzpicture}
}
\caption{Vettore $\hat{P}$ ruotato di $\varphi$ gradi rispetto alla base.} \label{fig:rot}
\end{figure}

Dallo studio della variazione troviamo che:

\begin{equation}\label{sistema1}
\begin{cases} 
x=x' \\ 
y=y'cos(\varphi)-z'sin(\varphi) \\ 
z=y'sin(\varphi)-z'cos(\varphi)
\end{cases} 
\end{equation}


Per comodità di calcolo nei successivi passaggi il sistema \eqref{sistema1} viene riscritto in forma matriciale.

\begin{equation}\label{rx}
R_x(\varphi)=
\begin{bmatrix}
1 & 0 & 0\\
0 & cos(\varphi) & -sin(\varphi)\\
0 & sin(\varphi) & cos(\varphi)
\end{bmatrix}
\quad : \quad
\begin{bmatrix}
x \\
y \\
z 
\end{bmatrix}
=R_x(\varphi)\cdot\begin{bmatrix}
x' \\
y' \\
z' 
\end{bmatrix}
\end{equation}
Risultati analoghi si ottengono per le rotazioni indipendenti di $\vartheta$ e $\psi$:
\begin{equation}\label{ry}
R_y(\vartheta)=
\begin{bmatrix}
cos(\vartheta) & 0 & sin(\vartheta)\\
0 & 1 & 0\\
-sin(\vartheta) & 0 & cos(\vartheta)
\end{bmatrix}
\quad : \quad
\begin{bmatrix}
x \\
y \\
z 
\end{bmatrix}
=R_y(\vartheta)\cdot\begin{bmatrix}
x' \\
y' \\
z' 
\end{bmatrix}
\end{equation}
\begin{equation}\label{rz}
R_z(\psi)=
\begin{bmatrix}
cos(\psi) & -sin(\psi) & 0\\
sin(\psi) & cos(\psi) & 0\\
0 & 0 & 1\\
\end{bmatrix}
\quad : \quad
\begin{bmatrix}
x \\
y \\
z 
\end{bmatrix}
=R_z(\psi)\cdot\begin{bmatrix}
x' \\
y' \\
z' 
\end{bmatrix}
\end{equation}

Le singole matrici possono essere viste come applicazioni lineari, si procede quindi nella moltiplicazione di \eqref{rx}, \eqref{ry} e \eqref{rz} per ottenere una singola applicazione lineare composta. Notare che nel prodotto tra matrici non vale la proprietà commutativa, bisogna quindi valutare attentamente l'ordine di moltiplicazione, altrimenti si otterrà una rotazione erronea. I passaggi intermedi vengono omessi in quanto ripetono tre volte una semplice operazione di moltiplicazione tra matrici.
\begin{align}\label{rg}
    R_g &= R_z(\psi)\cdot R_y(\vartheta)\cdot R_x(\varphi)\\
    		&= \begin{bmatrix}
			cos(\vartheta)cos(\psi) & -cos(\varphi)sin(\psi)+sin(\varphi)sin(\vartheta)cos(\psi) & sin(\varphi)sin(\psi)+cos(\varphi)sin(\vartheta)cos(\psi)\\
			cos(\vartheta)sin(\psi) & cos(\varphi)cos(\psi)+sin(\varphi)sin(\vartheta)sin(\psi) & -sin(\varphi)cos(\psi)+cos(\varphi)sin(\vartheta)sin(\psi)\\
			-sin(\vartheta) & sin(\varphi)cos(\vartheta) & cos(\varphi)cos(\vartheta)
			\end{bmatrix}
\end{align}

Moltiplicando il vettore $\hat{p_i}$ per la matrice di rotazione \eqref{rg} si ottengono le coordinate del punto $P_i$ relative al sistema di riferimento della base. 

\subsubsection{Conclusione problema piattaforma}
Grazie ai risultati ottenuti nelle sezioni \ref{xyz} e \ref{ftp} si possono definire i vettori $\hat{q_i}$ che descrivono la posizione dei punti $P_i$ rispetto al centro del sistema di riferimento della base $O$ per ogni operazione rototraslativa.
\begin{equation}\label{qi}
\hat{q_i}=\hat{T}+R_g\cdot \hat{p_i}
\end{equation}
Una volta ottenuto questo vettore, con una semplice operazione vettoriale, si può risalire a $\hat{l_i}$, vettore che descrive la distanza tra l'asse del servomotore e il corrispettivo giunto sulla piattaforma.

\begin{align}\label{li}
\hat{l_i}=\hat{T}+R_g\cdot \hat{p_i}-\hat{b_i}
\end{align}
Nel caso della piattaforma di Stewart, sei equazioni \eqref{li} permettono di descrivere la posizione della piattaforma al variare di $(x,y,z,\varphi,\vartheta,\psi)$.
Notare come, nel caso di impiego di attuatori lineari, il problema si risolve assegnando direttamente queste lunghezze per ottenere la posizione desiderata. 

\subsection{Analisi problema attuatori rotativi}\label{rotation}
L'impiego di servomotori complica ulteriormente le equazioni, è infatti necessario un numero di variabili superiore per descrivere in modo appropriato il sistema. Ogni servomotore controlla un giunto biella manovella collegato alla piattaforma che regola la lunghezza del vettore $\hat{l_i}$, fondamentale è quindi trovare una relazione tra l'angolo del servomotore e il vettore $\hat{l_i}$. Anche in questo caso la soluzione si ottiene dalla scomposizione del problema in due parti: la determinazione della posizione del giunto biella manovella e la ricerca dell'angolo di rotazione $\alpha$.

\begin{figure}[h!]
\centering
\scalebox{1}{
\begin{tikzpicture}
\filldraw [fill=blue!50](1cm,0cm) rectangle (2,2);
\filldraw [fill=black] (1.5cm,1.5cm) circle (3pt);
\filldraw [fill=blue!50](-1cm,0cm) rectangle (-2,2);
\filldraw [fill=black] (-1.5cm,1.5cm) circle (3pt);
\filldraw  [fill=black!50](-3cm,0cm) rectangle (3cm,-0.25cm);
\filldraw  [fill=black!50](-3cm,2cm) rectangle (3cm,2.25cm);
\draw  (1.5cm,1.5cm) -- node[anchor=south, xshift= 0cm,yshift=-0.45cm]{$m$}(3cm,0.75cm);
\draw  (3cm,0.75cm) -- node[anchor=west]{$b$}(4cm,7cm);
\draw  (-1.5cm,1.5cm) -- (-3cm,0.75cm);
\draw  (-3cm,0.75cm) -- (-4cm,7cm);
\filldraw  [fill=black!50]  (-4cm,7cm) rectangle (4cm,7.25cm);
%\draw [line width=2pt] (1cm,3cm) -- node[anchor=east, xshift= 0.6cm,yshift=-0.45cm]{$m$}(3cm,2cm);
%\filldraw [fill=black] (3cm,2cm) circle (3pt);
%\filldraw [fill=black] (2cm,9cm) circle (3pt);
%\draw [line width=2pt] (3cm,2cm) -- node[anchor=west]{$b$}(2cm,9cm);
\draw [dashed] (1.5cm,1.5cm) -- node[anchor=east]{$l$}(4cm,7cm);
\draw [dashed] (-1.5cm,1.5cm) -- (-4cm,7cm);
%\draw [<->] (3.5cm,2.2cm) arc (150:125:33.7pt);
\filldraw [fill=black] (-3cm,0.75cm) circle (1.5pt);
\filldraw [fill=black] (3cm,0.75cm) circle (1.5pt);
\filldraw [fill=black] (-4cm,7cm) circle (1.5pt);
\filldraw [fill=black] (4cm,7cm) circle (1.5pt);
\draw (-2.5cm,1.5cm) arc (-180:-158:1.2cm)node[anchor=east, yshift=0.2cm, xshift=-0.1cm]{$\alpha$};
\draw [dashed] (-1.5cm,1.5cm) -- (-2.5cm,1.5cm);
\end{tikzpicture}
}
\caption{Sistema biella manovella con servomotori in proiezione frontale.} \label{fig:rv}
\end{figure}

\subsubsection{Posizione del giunto biella manovella}
Note le lunghezze della biella $b$ e della manovella $m$, si valuta l'angolo di inclinazione dei servomotori rispetto all'asse $x$ e si indica con $\beta$, e si nota come i servomotori siano a due a due specchiati. Due set di equazioni saranno quindi necessarie per descrivere i motori pari e dispari al variare di $\alpha$.
\begin{equation}\label{bmpari}
    \begin{cases}
      x_{bm}=m \cdot cos(\alpha)cos(\beta)+x_b\\
      y_{bm}=m \cdot cos(\alpha)sin(\beta)+y_b\\
      z_{bm}=m \cdot sin(\alpha)+z_b\\
    \end{cases}\quad pari
\end{equation}
\begin{equation}\label{bmdispari}
    \begin{cases}
      x_{bm}=m \cdot cos(\alpha)cos(\pi+\beta)+x_b\\
      y_{bm}=m \cdot cos(\alpha)sin(\pi+\beta)+y_b\\
      z_{bm}=m \cdot sin(\alpha)+z_b\\
    \end{cases}\quad dispari
\end{equation}
Applicando le nozioni trigonometriche: 
$$cos(\alpha)=-cos(\alpha) \quad cos(\pi+\beta)=-cos(\beta) \quad sin(\pi+\beta)=-sin(\beta)$$
ai sistemi \eqref{bmpari} e \eqref{bmdispari} risulta evidente che questi due sono equivalenti.
\subsubsection{Determinazione angolo \boldmath$\alpha$}
Per la determinazione dell'angolo $\alpha$ ottimale esistono due tecniche principali. La prima consiste in una ricerca binaria (o dicotomica) del valore che meglio soddisfa le equazioni della posizione. La seconda prevede un approccio matematico più estensivo per determinare il valore \textbf{esatto} di $\alpha$ in base ad una $l$ fornita. Il primo approccio risulta più semplice dal punto di vista realizzativo ma a suo discapito è poco efficiente, in quanto richiede un numero arbitrario di iterazioni per raggiungere una determinata precisione di $\alpha$.\footnote{Mediamente un algoritmo di ricerca binaria assume una complessità \emph{O(log n)}, dove \emph{n} è direttamente correlato alla precisione del valore ottenuto.} Il secondo è invece più difficile da ottenere a causa dei calcoli non del tutto intuitivi ma garantisce di raggiungere la soluzione ottimale con una sola computazione. Per lo svolgimento del progetto è stata impiegata la seconda opzione.

Per il teorema di Pitagora in tre dimensioni abbiamo che:
\begin{align}\label{m2}
    m^2 &= (x_{bm}-x_b)^2+(y_{bm}-y_b)^2+(z_{bm}-z_b)^2\\
    		&= (x_{bm}^2+y_{bm}^2+z_{bm}^2)+(x_{b}^2+y_{b}^2+z_{b}^2)-2(x_{bm}x_b+y_{bm}y_b+z_{bm}z_b)
\end{align}
\begin{align}\label{l2}
    l^2 &= (x_{q}-x_b)^2+(y_{q}-y_b)^2+(z_{q}-z_b)^2\\
    		&= (x_{q}^2+y_{q}^2+z_{q}^2)+(x_{b}^2+y_{b}^2+z_{b}^2)-2(x_{q}x_b+y_{q}y_b+z_{q}z_b)
\end{align}
\begin{align}\label{b2}
    b^2 &= (x_{q}-x_{bm})^2+(y_{q}-y_{bm})^2+(z_{q}-z_{bm})^2\\
    		&= (x_{q}^2+y_{q}^2+z_{q}^2)+(x_{bm}^2+y_{bm}^2+z_{bm}^2)-2(x_{q}x_{bm}+y_{q}y_{bm}+z_{q}z_{bm})
\end{align}

I valori di $m^2$, $l^2$ e $b^2$ sono noti, si sostituiscono le equazioni \eqref{m2} e \eqref{l2} in \eqref{b2}, si ottiene:
\begin{align}\label{passaggio}
    l^2-(b^2-m^2) =& 2(x_{b}^2+y_{b}^2+z_{b}^2)+2x_{bm}(x_q-x_b)+2y_{bm}(y_q-y_b)+2z_{bm}(z_q-z_b)\\ 
    				   & -2(x_qx_b+y_qy_b+z_qz_b)
\end{align}

Si sostituiscono le equazioni dei valori noti $x_{bm}$, $y_{bm}$ e $z_{bm}$ calcolate in \eqref{bmpari} e si svolgono le dovute semplificazioni.
\begin{align}\label{passaggio}
    l^2-(b^2-m^2) =& 2(x_{b}^2+y_{b}^2+z_{b}^2)+2[m \cdot cos(\alpha)cos(\beta)+x_b](x_q-x_b)\\
    &+2[m \cdot cos(\alpha)sin(\beta)+y_b](y_q-y_b)+2[m \cdot sin(\alpha)+z_b](z_q-z_b)\\ 
    				   & -2(x_qx_b+y_qy_b+z_qz_b)\\
    				   =& 2m \cdot cos(\alpha)cos(\beta)(x_q-x_b)+2m \cdot cos(\alpha)sin(\beta)(y_q-y_b)\\
    				   & +2m \cdot sin(\alpha)(z_q-z_b)\\
    				   =& 2m \cdot sin(\alpha)(z_q-z_b) +2m \cdot cos(\alpha)[cos(\beta)(x_q-x_b)+sin(\beta)(y_q-y_b)]   
\end{align}

L'equazione \eqref{passaggio} è nella forma $L=Mcos(\alpha)+Nsin(\alpha)$ e può essere ulteriormente compattata considerando la formula della somma di segnali sinusoidali di diversa ampiezza, secondo la quale un segnale $Acos(\alpha)+Bsin(\alpha)$ può essere riscritto come $Csin(\alpha + \nu)$, infatti:
\begin{equation}\label{c}
Csin(\alpha + \nu)=Csin(\alpha)\cdot cos(\nu)+Ccos(\alpha)\cdot sin(\nu)
\end{equation}
\begin{equation}\label{tg}
    \begin{cases}
      A=Ccos(\nu)\\
      B=Csin(\nu)\\
    \end{cases}\quad \Rightarrow \quad  C=\sqrt{A^2+B^2}, \quad \nu=arctan\left(\frac{B}{A}\right)
\end{equation}

Applicando il risultato ottenuto in \eqref{tg} possiamo quindi scrivere:
\begin{align}\label{alfa}
    L= \sqrt{M^2+N^2}\cdot sin\left(\alpha+arctan\left(\frac{N}{M}\right)\right) \quad  &\Rightarrow\\ sin\left(\alpha+arctan\left(\frac{N}{M}\right)\right)=\frac{L}{\sqrt{M^2+N^2}}  \quad  &\Rightarrow\\
    \alpha=arsin\left(\frac{L}{\sqrt{M^2+N^2}}\right)-arctan\left(\frac{N}{M}\right)
\end{align}
Con rispettivamente:
\begin{equation}\label{lnm}
L=l^2-(b^2-m^2), \quad M=2m(z_q-z_b), \quad N=2m[cos(\beta)(x_q-x_b)+sin(\beta)(y_q-y_b)]
\end{equation}
Si conclude così la ricerca dell'angolo $\alpha$.

\subsubsection{Controllo servomotori}
Al fine di controllare i servomotori in modo ottimale è necessario effettuare alcuni accorgimenti.
É necessario definire un'altezza $h_0$ e un angolo $\alpha_0$ di riposo dei servomotori, questo è scelto in modo che le manovelle dei servomotori siano orizzontali, quindi $\alpha_0=0^\circ$, l'altezza è ricavata sperimentalmente valutando a quale valore di $h$ i servomotori lavorano specularmente rispetto all'asse $x$.
Siccome i servomotori hanno caratteristiche variabili a seconda del produttore bisogna definire una relazione tra la variazione in $\mu s$ del segnale PWM e la variazione dell'angolo $\alpha$ in radianti. Notare inoltre come questa relazione non valga quando il servomotore si trova vicino alla massima escursione, per avere una misura accurata analizziamo quanti $\mu s$ sono necessari per variare $\alpha$ dalla posizione orizzontale a 45°, questo è svolto nel rapporto:
\begin{align}\label{rel}
r &=\frac{\Delta t}{\Delta\alpha}\cdot \frac{360^\circ}{2 \pi}\\
	&= \frac{375}{45^\circ}\cdot \frac{360^\circ}{2 \pi} \quad [\mu s/rad]
\end{align}
Dopo essere risaliti sperimentalmente al valore $\Delta t = 375 \mu s$. In questo modo moltiplicando un angolo $\alpha$ per la \eqref{rel} otteniamo i corrispettivi $\mu s$ da assegnare al servomotore. Si possono quindi scrivere le equazioni di controllo per i servomotori, distinguendo sempre tra pari e dispari.
\begin{equation}\label{w}
    \begin{cases}
      w_i=w_i^0 +(\alpha_i-\alpha_0)\cdot r	\quad pari \\
      w_i=w_i^0 +(\alpha_i-\alpha_0)\cdot r	\quad dispari \\
    \end{cases}
\end{equation}
Dove $w_i^0$ indicano le posizioni a riposo dei servomotori in $\mu s$.
Per migliorare la sicurezza del sistema è stato introdotto un controllo degli angoli assegnati ai servomotori, in modo da evitare possibili sforzi.
Il sistema di controllo analizza tutti i valori di $w_i$ prima che questi siano assegnati ai servomotori, li confronta con un range di valori accettabili e verifica che non siano valori impossibili (NaN).
Se le condizioni sono rispettate procede assegnando i valori, altrimenti entra in una routine di allarme e blocca il sistema. Il funzionamento globale del sistema è riassunto nello schema a blocchi presente nella sezione \ref{schemablocchi}.

\subsection{Schema a blocchi}\label{schemablocchi}
Questo schema logico descrive in modo riassuntivo il controllo della piattaforma di Stewart con attuatori rotativi, nonché gli accorgimenti necessari a rendere il sistema più sicuro in caso di valori di ingresso errati.

\begin{figure}[h!]
\centering
\scalebox{1}{
\begin{tikzpicture}[font=\small,thick]
 
% Start block
\node[draw,
    rounded rectangle,
    minimum width=2.5cm,
    minimum height=1cm, text width=5cm, text centered] (block1) {Caratteristiche piattaforma e servomotori};
    
    % Power and voltage variation
\node[draw,
    below=of block1,
    minimum width=3.5cm,
    minimum height=1cm
] (block2) { Determina $h_0$ e $\alpha_0$};
    
% Voltage and Current Measurement
\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    below=of block2,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block3) { Riceve posizione $x,y,z,\varphi,\vartheta,\psi$};

\node[draw,
    below=of block3,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block4) {  Calcolo matrice rotazione $R_g$};

\node[draw,
    below=of block4,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=2.5cm, text centered
] (block5) { Calcolo distanza $l$};

\node[draw,
    below=of block5,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block6) { Calcolo $\alpha$ e il corrispettivo $w$};

\node[draw,
    diamond,
    right=of block6,
    minimum width=3.5cm,
    inner sep=2, aspect=2, xshift= 1.2cm] (block7) {Fuori range?};
    
\node[draw,
    right=of block7,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3.2cm, text centered, xshift=1.2cm
] (blocco) { Blocco sistema e accendo lampeggiate};

\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    above=of block7,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered, yshift= 0.75cm
] (block8) {Imposta $w$ ai servomotori};
 
% Conditions test
\node[draw,
    diamond,
    above=of block8,
    minimum width=3.5cm,
    inner sep=2, aspect=2, yshift= 0.75cm] (block9) { Nuova posizione?};
    
\node[draw,
    above right=of block9,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block10) { Mantieni posizione};
 

% Arrows
\draw[-latex] (block1) edge (block2)
			  (block2) edge (block3)
			  (block3) edge (block4)
			  (block4) edge (block5)
			  (block5) edge (block6)
   			  (block6) edge (block7)
   			  (block8) edge (block9);
   
\draw[-latex] (block7) -- (blocco) node[pos=0.2,fill=white,inner sep=2]{Sì};
 
\draw[-latex] (block7) -- (block8) node[pos=0.2,fill=white,inner sep=2]{No};

\draw[-latex] (block9) -- (block3) node[pos=0.2,fill=white,inner sep=2]{Sì};
 
\draw[-latex] (block9) |- (block10) node[pos=0.2,fill=white,inner sep=2]{No};
    
\draw[-latex] (block10) |- (block9);


\end{tikzpicture}
}
\caption{Schema logico piattaforma di Stewart.} \label{fig:ps}
\end{figure}

\newpage
\section{Controllo della pallina con piano stabilizzato}
\subsection{Controllore PID}\label{pid}
Il controllore PID è l'elemento chiave per il corretto funzionamento del sistema di stabilizzazione, esso riceve in ingresso la posizione della palla sul piano resistivo e si occupa di fornire opportuni parametri alla piattaforma di Stewart per fare in modo che sia raggiunto un determinato setpoint.
Questa azione di controllo è svolta tramite la combinazione lineare di tre contributi fondamentali, il proporzionale, l'integrale e il derivativo, da cui prende il nome. Questi effetti sono gestiti da tre variabili indipendenti $K_p$, $K_i$ e $K_d$ che ne pesano il contributo. 

\subsubsection{Equazione del controllore PID}

Segue un'analisi delle tre equazioni che permettono il controllo del sistema:

\begin{itemize}
\item Il controllore proporzionale ha equazione $u(t)=K_p \cdot e(t)$ e come si può facilmente notare ha lo scopo di rispondere in modo lineare allo scostamento della palla dalla posizione desiderata, lavora al presente.
\item Il controllore integrale ha equazione $u(t)=K_i \cdot \int_0^t e(\tau)d\tau$, il suo valore aumenta in relazione al tempo e alla distanza della pallina dal setpoint. Ha quindi lo scopo di annullare l'errore a riposo del sistema, lavora nel passato.
\item Il controllore derivativo ha equazione $u(t)=K_d\cdot \frac{de(t)}{dt}$, si oppone quindi alla variazione dell'errore ed è fondamentale per la stabilità del problema, lavora nel futuro.
\end{itemize}
Questi tre elementi sommati restituiscono l'equazione tempo continua seguente:

\begin{equation}\label{pidtc}
    u(t)=K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau)d\tau + K_d\cdot \frac{de(t)}{dt}
\end{equation}

Si può quindi procedere rappresentando complessivamente il sistema da controllare
e il relativo controllore, che risulta essere come in figura \ref{fig:ps}.

\begin{figure}[h!]
\centering
\scalebox{0.8}{
\begin{tikzpicture}[font=\small,thick]
 
% Start block
\node[draw,
    circle,
    minimum width=1cm,
     text centered] (block1) {$\Sigma$};
    
    % Power and voltage variation
\node[draw,
    right=of block1,
    minimum width=1cm,
    minimum height=1cm, xshift= 1cm
] (block2) {$K_i$};

\node[draw,
    right=of block2,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (int) {$\int_0^t$};



\node[draw, right=of int, 
    circle,
    minimum width=1cm,
     text centered] (S) {$\Sigma$};
    

\node[draw,
    right=of S,
    minimum width=2cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block3) {Piattaforma Stewart};

\node[draw,
    right=of block3,
    minimum width=2cm,
    minimum height=1cm,
    text width=3cm, text centered
] (block4) {Piano resistivo};
 
\node[draw,
    above=of block2,
    minimum width=1cm,
    minimum height=1cm,yshift=-0.5cm
] (P) {$K_p$};

\node[draw,
    below=of block2,
    minimum width=1cm,
    minimum height=1cm,yshift=0.5cm
] (D) {$K_d$};

\node[draw,
    right=of D,
    minimum width=1cm,
    minimum height=1cm,
     text centered
] (der) {$\frac{d}{dt}$};

% Arrows
\draw [-latex] (-2cm,0cm) -- node[anchor=south]{$x(t)$}(block1)node[xshift=-0.75cm,yshift=-0.25cm]{$+$}node[xshift=0.25cm,yshift=-0.75cm]{$-$};
\draw [-latex] (block1) edge (block2)node[anchor=south, xshift=1cm]{$e(t)$};
\draw [-latex](1.5,0) |- (D);
\draw [-latex](1.5,0) |- (P);
\draw [-latex](D) edge (der);
\draw [-latex](block2) edge (int);
\draw [-latex](D) edge (der);
\draw [-latex](int) -- (S);
\draw [-latex](P) -| (S)node[xshift=0.25cm,yshift=0.75cm]{$+$}node[xshift=-0.75cm,yshift=0.25cm]{$+$}node[xshift=-0.25cm,yshift=-0.75cm]{$+$};
\draw [-latex]	(der) -| (S);
\draw [-latex]	(S) edge (block3);	
\draw [-latex]	(block3) edge (block4);
\draw [-latex]	(block4) -- (18,0);	
\draw 	(17,0)node[anchor=south]{$u(t)$} -- (17,-3);		  
\draw [-latex]	(17,-3) -| (block1);	


\end{tikzpicture}
}
\caption{Schema logico controllore PID applicato al problema.} \label{fig:ps}
\end{figure}


Lavorando con sistemi digitali tempo discreti non è però possibile impiegare la formula \eqref{pidtc}, sarà necessario procedere ad una discretizzazione, questa viene in modo intuitivo applicando la nozione di differenze finite e considerando $\Delta t = t_k - t_{k-1}$ come periodo di campionamento. Il risultato è la seguente equazione:

\begin{equation}\label{pidtd}
    u(t_k)=K_p \cdot e(t_k) + K_i \cdot \sum_{i=1}^{t_k} e(t_i)\cdot \Delta t + K_d\cdot \frac{e(t_k)-e(t_{k-1})}{\Delta t}
\end{equation}



\subsection{Miglioramenti e ottimizzazioni del controllore PID}
Nonostante il PID sia di per sé un ottimo contro teorico, nella realtà sono necessari degli accorgimenti per evitare comportamenti erronei che possono compromettere la stabilità del sistema. Segue una lista delle migliorie impiegate.
\begin{itemize}
\item Filtraggio del segnale in ingresso: passo fondamentale per ottenere un sistema di controllo performante, dati rumorosi in ingresso hanno ripercussioni catastrofiche sull'intero controllore.
\item Filtraggio dell'azione derivativa: la derivata, per sua natura, si comporta come un amplificatore di segnali in alta frequenza. Questo induce un comportamento "nervoso" che va quanto più limitato. 
\item Derivata sulla misura: utile per evitare un brusco scatto al cambio del setpoint e del tutto analoga alla derivata sull'errore con la sola differenza del segno invertito.
\item Anti-windup dell'integrale: il termine integrale può tendere a infinito nel caso l'errore non si annulli mantenendo sempre lo stesso segno, questo fenomeno è noto come windup e comporta il fallimento del sistema di controllo se prolungato per un tempo sufficientemente grande. Per evitare questo spiacevole effetto è utile limitare la somma del termine integrale in modo che questo si annulli rapidamente al cambio di segno dell'errore.
\item Limitazione dell'uscita: il controllore, non conoscendo i limiti fisici del progetto, può assegnare valori inammissibili al sistema da controllare, il che potrebbe anche risultare in una rottura. Si devono quindi stabilire dei limiti al range di valori assegnabili dal controllore.
\end{itemize}

\begin{figure}[h!]
\centering
\scalebox{1}{
\begin{tikzpicture}[font=\small,thick]
 
% Start block
\node[draw,
    rounded rectangle,
    minimum width=2.5cm,
    minimum height=1cm, text width=2cm, text centered] (start) {Accensione};
    
    
% Voltage and Current Measurement
\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    below=of block2,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered, below=of start
] (lettura) {Lettura posizione palla};

\node[draw,
    below=of lettura,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (calcolo) {  Calcolo velocità e accelerazione};

\node[draw,
    below=of calcolo,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=2.5cm, text centered
] (filtro) { Filtro limitando variazione};

\node[draw,
    below=of filtro,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered
] (pid) { PID migliorato};

\node[draw,
    diamond,
    right=of pid,
    minimum width=3.5cm,
    inner sep=2, aspect=2, xshift= 1.2cm] (acc) {Valore accettabile?};
    
\node[draw,
    trapezium, 
    trapezium left angle = 120,
    trapezium right angle = 120,
    trapezium stretches,
    below=of block2,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered, above=of acc, yshift= 0.5cm
] (piatt) {Assegna valore piattaforma};


\node[draw,
    right=of acc,
    minimum width=3.5cm,
    minimum height=1cm,
    text width=3cm, text centered, xshift= 1.2cm
] (max) { Usa valore massimo};
 

% Arrows
\draw 	[-latex](start) edge (lettura);		  
\draw [-latex]	(lettura) edge (calcolo);
\draw [-latex]	(calcolo) edge (filtro);	
\draw [-latex]	(filtro) edge (pid);
\draw [-latex]	(pid) edge (acc);
\draw [-latex]	(acc) edge (max)node[fill=white,inner sep=2,xshift = 2.5cm]{No};
\draw [-latex]	(max) |- (piatt);
\draw [-latex]	(acc) edge (piatt) node[fill=white,inner sep=2, yshift=1.5cm]{Sì};
\draw [-latex]	(piatt) |- (lettura);


\end{tikzpicture}
}
\caption{Schema logico sistema di stabilizzazione.} \label{fig:ps}
\end{figure}


\bibliographystyle{alpha}
\bibliography{references} % see references.bib for bibliography management

\end{document}


